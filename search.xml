<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣 1768. 交替合并字符串</title>
    <url>/leetcode/1768.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeAlternately</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    ret = <span class="string">&quot;&quot;</span></span><br><span class="line">    i, a_len, b_len = <span class="number">0</span>, <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    <span class="keyword">while</span> i &lt; a_len <span class="keyword">and</span> i &lt; b_len:</span><br><span class="line">        ret += word1[i] + word2[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; a_len: ret += word1[i:]</span><br><span class="line">    <span class="keyword">if</span> i &lt; b_len: ret += word2[i:]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 901. 股票价格跨度</title>
    <url>/leetcode/1235.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>可以转化为背包问题</p>
<p>dp[i]表示做到第i份工作后的最大利益</p>
<p>因此在面对第i件工作时有两种情况</p>
<ol>
<li>不做第i件工作：dp[i] &#x3D; dp[i - 1]</li>
<li>做第i件工作，利益承接和第i件工作不冲突的dp：dp[i] &#x3D; dp[k] + profit[i]<ol>
<li>查找和第i件不冲突的工作k: bisect_right(data, starttime[i], hi&#x3D;i, key&#x3D;endtime[i])</li>
<li>完成第k件工作，还可以完成第i件工作</li>
</ol>
</li>
</ol>
<p>综合上述情况 dp[i] &#x3D; max(dp[i - 1], dp[k] + profit[i])</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jobScheduling</span>(<span class="params">startTime, endTime, profit</span>):</span><br><span class="line">    <span class="comment"># 背包问题 + 二分查找</span></span><br><span class="line">    n = <span class="built_in">len</span>(profit)</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    data = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(startTime, endTime, profit), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        k = bisect_right(data, data[i - <span class="number">1</span>][<span class="number">0</span>], hi=i, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], data[i - <span class="number">1</span>][-<span class="number">1</span>] + dp[k])</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 901. 股票价格跨度</title>
    <url>/leetcode/901.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分别保存每日股价以及每日股票跨度，</p>
<p>对每日股价倒叙查找，判断查找的股价小于等于当日股价，则根据他的股票跨度进行倒退，再次判断直到查找的股价大于当日股价，</p>
<p>得到最终当日股价的跨度。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.prices = []</span><br><span class="line">        self.dp = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur, dp = <span class="built_in">len</span>(self.prices) - <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur &gt; -<span class="number">1</span> <span class="keyword">and</span> self.prices[cur] &lt;= price:</span><br><span class="line">            dp += self.dp[cur]</span><br><span class="line">            cur -= self.dp[cur]</span><br><span class="line">        self.prices.append(price)</span><br><span class="line">        self.dp.append(dp)</span><br><span class="line">        <span class="keyword">return</span> self.dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 779. 第K个语法符号</title>
    <url>/leetcode/779.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>0<br>01<br>0110<br>01101001<br>……</p>
</blockquote>
<p>可以看出，每一层前半是上一层的复制，后半是上一层的求反</p>
<p>因此，若k在当前层的前半，就是上一层的值；若k在当前层的后半，就是上一层k-2**(n-1)&#x2F;2的反值。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kthGrammar</span>(<span class="params">n, k</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span> &lt;&lt; (n -<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> kthGrammar(n - <span class="number">1</span>, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> kthGrammar(n - <span class="number">1</span>, k - (<span class="number">1</span> &lt;&lt; (n - <span class="number">2</span>))) ^ <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 1700. 无法吃午餐的学生数量</title>
    <url>/leetcode/1700.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="模拟1"><a href="#模拟1" class="headerlink" title="模拟1"></a>模拟1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countStudents</span>(<span class="params">students, sandwiches</span>):</span><br><span class="line">    s1 = <span class="built_in">sum</span>(students)</span><br><span class="line">    s0 = <span class="built_in">len</span>(students) - s1</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sandwiches:</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">and</span> s1:</span><br><span class="line">            s1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> x == <span class="number">0</span> <span class="keyword">and</span> s0:</span><br><span class="line">            s0 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> s0 + s1</span><br></pre></td></tr></table></figure>

<h1 id="模拟2"><a href="#模拟2" class="headerlink" title="模拟2"></a>模拟2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countStudents</span>(<span class="params">students, sandwiches</span>):</span><br><span class="line">    cur, flag = <span class="built_in">len</span>(sandwiches), <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cur):</span><br><span class="line">            <span class="keyword">if</span> sandwiches[<span class="number">0</span>] == students[<span class="number">0</span>]:</span><br><span class="line">                sandwiches.pop(<span class="number">0</span>)</span><br><span class="line">                students.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                students.append(students.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="built_in">len</span>(sandwiches):</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = <span class="built_in">len</span>(sandwiches)</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 902. 最大为N的数字组合</title>
    <url>/leetcode/902.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">atMostNGivenDigitSet</span>(<span class="params">digits, n</span>):</span><br><span class="line">    n_s = <span class="built_in">str</span>(n)</span><br><span class="line">    m, k = <span class="built_in">len</span>(digits), <span class="built_in">len</span>(n_s)</span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">            <span class="keyword">if</span> d == n_s[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> d &lt; n_s[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i][<span class="number">0</span>] += dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            dp[i][<span class="number">0</span>] += m + dp[i - <span class="number">1</span>][<span class="number">0</span>] * m</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp[k])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 300. 最长递增子序列</title>
    <url>/leetcode/300.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="时间复杂度-O-n-2"><a href="#时间复杂度-O-n-2" class="headerlink" title="时间复杂度$O(n^2)$"></a>时间复杂度$O(n^2)$</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment">#  动态规划</span></span><br><span class="line">    dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">    ret = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i])</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, dp[i])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h1 id="时间复杂度-O-nlogn"><a href="#时间复杂度-O-nlogn" class="headerlink" title="时间复杂度$O(nlogn)$"></a>时间复杂度$O(nlogn)$</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment">#  动态规划 + 二分查找</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        i, j = <span class="number">0</span>, ret</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = i + j &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[m] &lt; num:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = m</span><br><span class="line">        dp[i] = num</span><br><span class="line">        <span class="keyword">if</span> i == ret: ret += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 297. 二叉树的序列化</title>
    <url>/leetcode/297.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="层序遍历树"><a href="#层序遍历树" class="headerlink" title="层序遍历树"></a>层序遍历树</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">        <span class="comment"># 层序遍历</span></span><br><span class="line">        ret, queue = [], [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">                    ret.append(<span class="string">&quot;null&quot;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                ret.append(cur.val)</span><br><span class="line">                queue.append(cur.left)</span><br><span class="line">                queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, ret))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 层序构建树</span></span><br><span class="line">        data = data.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&quot;null&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head = TreeNode(<span class="built_in">int</span>(data[<span class="number">0</span>]))</span><br><span class="line">        nodes = [head]</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(data[j])) <span class="keyword">if</span> data[j] != <span class="string">&quot;null&quot;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                nodes.append(node.left)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= <span class="built_in">len</span>(data):</span><br><span class="line">                    <span class="keyword">return</span> head</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(data[j])) <span class="keyword">if</span> data[j] != <span class="string">&quot;null&quot;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                nodes.append(node.right)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= <span class="built_in">len</span>(data):</span><br><span class="line">                    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 287. 寻找重复数</title>
    <url>/leetcode/287.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 二分查找</span></span><br><span class="line">    left, right = <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= mid:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 双指针</span></span><br><span class="line">    low, fast = nums[<span class="number">0</span>], nums[nums[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> low != fast:</span><br><span class="line">        low = nums[low]</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">    fast = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> low != fast:</span><br><span class="line">        low = nums[low]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 283. 移动零</title>
    <url>/leetcode/283.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>        </span><br><span class="line">    s, e, L = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> s &lt; L <span class="keyword">and</span> e &lt; L:</span><br><span class="line">        <span class="comment"># 找0值</span></span><br><span class="line">        <span class="keyword">while</span> s &lt; e <span class="keyword">and</span> nums[s] != <span class="number">0</span>: s += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 找非0值</span></span><br><span class="line">        <span class="keyword">while</span> e &lt; L <span class="keyword">and</span> nums[e] == <span class="number">0</span>: e += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s &lt; L <span class="keyword">and</span> e &lt; L: </span><br><span class="line">            nums[s], nums[e] = nums[e], nums[s]</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            e += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 279. 完全平方数</title>
    <url>/leetcode/279.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = i</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>技巧，知识积累，持续更新</title>
    <url>/trick.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="堆的构建-以大根堆为例"><a href="#堆的构建-以大根堆为例" class="headerlink" title="堆的构建: 以大根堆为例"></a>堆的构建: 以大根堆为例</h1><blockquote>
<p><a href="https://blog.csdn.net/qq876940285/article/details/88360807">参考</a></p>
</blockquote>
<ol>
<li>找到堆中最后一个父节点</li>
<li>对比当前父节点和左右子节点的大小，最大的和较小的交换。</li>
<li>数组逆序到上一个父节点，执行第二步以后，如果交换的子节点还有子节点，执行第二步到叶节点</li>
<li>执行到根节点结束</li>
</ol>
]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 253. 会议室II</title>
    <url>/leetcode/253.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由于是会员题目，这里对题目进行描述</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间[[s1, e1], [s2,e2], …](si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排？</p>
<blockquote>
<p>示例1：<br>input： [[0, 30], [5, 10], [15, 20]]<br>output：2</p>
</blockquote>
<blockquote>
<p> 示例2：<br>input： [[7, 10], [2, 4]]<br>output：1</p>
</blockquote>
<h1 id="思路1-优先队列"><a href="#思路1-优先队列" class="headerlink" title="思路1 优先队列"></a>思路1 优先队列</h1><ol>
<li>按照开始时间对会议进行排序。</li>
<li>以会议结束时间构建最小堆，判断是否有会议室空着可使用。</li>
<li><ol>
<li>如果空闲，直接开始会议</li>
<li>如果不空闲，开新房间，加入堆</li>
</ol>
</li>
</ol>
<h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minMeetingRooms</span>(<span class="params">intervals</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 堆</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> heap <span class="keyword">and</span> heap[<span class="number">0</span>] &lt;= inter[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        heapq.heappush(heap, inter[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(heap)</span><br></pre></td></tr></table></figure>

<h1 id="思路2-双指针"><a href="#思路2-双指针" class="headerlink" title="思路2 双指针"></a>思路2 双指针</h1><ol>
<li>分别按照开始时间和结束时间对会议进行排序。</li>
<li>双指针分别指向开始和结束</li>
<li>会议室会随着开始指针右移一直增加，但如果开始指针大于等于结束指针，会议室数量-1，结束指针后移1位</li>
</ol>
<h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minMeetingRooms</span>(<span class="params">intervals</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 双指针</span></span><br><span class="line">    start, end = [], []</span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        start.append(inter[<span class="number">0</span>])</span><br><span class="line">        end.append(inter[<span class="number">1</span>])</span><br><span class="line">    start.sort()</span><br><span class="line">    end.sort()</span><br><span class="line">    left, right, ret = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(intervals):</span><br><span class="line">        <span class="keyword">if</span> start[left] &gt;= end[right]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            ret -= <span class="number">1</span></span><br><span class="line">        ret += <span class="number">1</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 240. 搜索二维矩阵II</title>
    <url>/leetcode/240.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">matrix, target</span>):</span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> ret <span class="keyword">and</span> i &lt; m <span class="keyword">and</span> j &gt; -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">            ret = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记 3</title>
    <url>/books/network_3.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>数据链路层使用的信道主要分为以下两种类型：</p>
<ol>
<li><strong>点对点信道</strong>。一对一的点对点通信。<br/> <br/></li>
<li><strong>广播信道</strong>。一对多的广播通信方式。</li>
</ol>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h3><blockquote>
<p>链路和数据链路的区别: </p>
<p><strong>链路</strong>(link)是从一个节点到相邻接点的一段物理线路，中间没有任何其他交换节点，只是一条路径的组成部分。</p>
<p><strong>数据链路</strong>(data link)包括物理线路以及必要的通信协议来控制数据的传输。把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
</blockquote>
<p>最常用的方法是使用<strong>网络适配器</strong>实现用于控制数据传输的协议。一般的适配器都包括了数据链路层和物理层两种功能。</p>
<blockquote>
<p>注: 因为早期的数据通信协议也叫做通信<strong>规程</strong>(procedure)。规程和协议是同义词。</p>
</blockquote>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>数据链路层把网络层下才来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据取出并上交给网络层。</p>
<h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><h3 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h3><p>为了主要关注数据链路层，使用3层和单层结构表示。</p>
<p><img src="/../images/network/data_link_3.png" alt="三层简化点对点数据链路层"></p>
<p><img src="/../images/network/data_link_1.png" alt="单层简化点对点数据链路层"></p>
<p>点对点的数据链路层进行通信的主要步骤如下：</p>
<ol>
<li>节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成<strong>帧</strong>。<br/> <br/></li>
<li>节点A把封装好的帧发送给节点B的数据链路层。<br/> <br/></li>
<li>若节点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层，否则丢弃这个帧。</li>
</ol>
<p>数据链路层不必考虑物理层如何实现比特传输的细节，甚至可以简单的设想数据是沿着两个数据链路层之间的水平方向把帧直接发送到对方。<br/> <br/></p>
<h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><ol>
<li><p><strong>封装成帧</strong></p>
<p><strong>封装成帧</strong>(framing)就是在一段数据的前后分别添加首部和尾部，来构成帧。<br/> <br/> </p>
<p>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到比特流中识别帧的开始和结束。<br/> <br/></p>
<p><img src="/../images/network/framing.png" alt="封装成帧"></p>
<p>网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，就构成了完整的帧。<br/> <br/></p>
<p>一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。<br/> <br/></p>
<p>帧首部和尾部的作用不仅是进行<strong>帧定界</strong>，此外还包含许多必要的控制信息。<br/> <br/></p>
<p>在发送帧时，是从帧首部开始的。各种数据链路层的协议都对帧首部和帧尾部的格式有明确的规定。<br/> <br/></p>
<p>为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送帧的数据部分的长度上限:<strong>最大传送单元MTU</strong>(Maximum Transfer Unit)<br/> <br/></p>
<p>当数据在传输中出现差错时，帧定界符就体现了它的作用。假定发送端在尚未发送完一个帧时突然出现故障，中断了发送，随后恢复正常，重头开始发送刚才未发送完的帧。在接收端，由于使用了帧定界符，接收端就知道前面收到的数据是不完整的帧，需要丢弃。下一个接收的帧是完整的帧，可以收下。<br/> <br/></p>
</li>
<li><p><strong>透明传输</strong><br/> <br/><br>所谓透明传输，即在数据链路层透明传送数据，表示无论怎样的比特组合数据，都能够原样没有差错地通过这个数据链路层。也就是说，对于传送的数据，数据链路层是”透明”的。<br/> <br/></p>
<p>为了解决透明传输问题，在帧的数据部分绝对不可以出现链路层协议所定义的SOH(Start of Header)以及EOT(End of Transmission)。<br/> <br/></p>
<p>为了解决帧的数据部分出现假性”SOH”和”EOT”，具体方式是<strong>字节填充</strong>(byte stuffing)&#x2F;<strong>字符填充</strong>(character stuffing)，即发送端的数据在假性”SOH”或”EOT”之前插入一个<strong>转义字符(ESC),0x1B</strong>，在接收端的数据链路层把数据送往网络层之前删除这个插入的转义字符。如果<strong>转义字符</strong>也出现在数据中，那么就在转义字符之前插入一个转义字符。<br/> <br/></p>
<p><img src="/../images/network/character_stuffing.png" alt="字节填充方法"></p>
</li>
<li><p><strong>差错检测</strong><br/> <br/></p>
<blockquote>
<p>比特差错： 比特在传输过程中可能会产生差错:1可能会变成0，0可能变成1。</p>
<p>误码率BER(bit error rate): 在一段时间内，传输错误的比特占所传输比特总数的比率。</p>
</blockquote>
<p>首先，这里的差错仅指比特差错，但在比特差错之上，还会有<strong>帧丢失</strong>，<strong>帧重复</strong>或<strong>帧失序</strong>。<br/> <br/></p>
<blockquote>
<p>发送端发送帧: [#1]-[#2]-[#3]</p>
<p>帧丢失: 接收端收到[#1]-[#3] 丢失[#2]</p>
<p>帧重复：收到[#1]-[#2]-[#2]-[#3] 收到两个[#2]</p>
<p>帧失序：收到[#1]-[#3]-[#2]</p>
</blockquote>
<p>无比特差错和无传输差错因此并不是同一个概念。因此在CRC检错(针对比特差错)的基础上增加了<strong>帧编号</strong>，<strong>确认</strong>和<strong>重传机制</strong>。<br/> <br/></p>
<p>收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认的为止。<br/> <br/></p>
<p>目前的做法是，对于通信质量良好的有线传输线路，数据链路层协议不使用确认和重传机制，不要求数据链路层向上层提供可靠的传输服务。如果出错，改正差错的任务交由上层协议完成。对于通信质量较差的的无线传输链路，数据链路层协议使用确认和重传机制，向上层提供可靠传输的服务。<br/> <br/></p>
<p>此节仅针对比特差错问题进行讨论，目前在数据链路层广泛使用的是<strong>循环冗余检验CRC</strong>(Cyclic Redundancy Check)技术。<br/> <br/></p>
<p>在发送端，CRC利用预先约定好的除数<em>P</em>对帧数据作除法操作，最终的余数作为冗余码，又叫<strong>帧检验序列FCS</strong>(Frame Check Sequence)，构成发送数据。<br/> <br/></p>
<p>在接收端，CRC以帧为单位进行检测。把接收的帧数据除以约定好的除数。如果得出的余数为0，判定此帧没有差错，接受。如果得出的余数不为0，判定此帧有差错，丢弃。<br/> <br/></p>
<p>使用多项式来表示CRC检验过程。此多项式称为生成多项式。<br/> <br/></p>
<p>目前广泛使用的生成多项式$ P(X) $包括:</p>
<ol>
<li>$ CRC-16 &#x3D; X^{16} + X^{15} + X^{2} + 1 $<br/> <br/></li>
<li>$ CRC-CCITT &#x3D; X^{16} + X^{12} + X^{5} + 1 $<br/> <br/></li>
<li>$ CRC-32 &#x3D; X^{32} + X^{26} + X^{23} + X^{22} + X^{16} + X^{12} + X^{11} + X^{10} + X^{8} + X^{7} + X^{5} + X^{4} + X^{2} + X + 1 $<br/> <br/></li>
</ol>
</li>
</ol>
<h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><p><strong>点对点协议PPP</strong>(Point-to-Point Protocol)是在目前通信线路质量变好的情况下点对点链路使用的数据链路层协议。<br/> <br/></p>
<p>PPP协议是用户计算机和ISP进行通信时所使用的数据链路层协议。</p>
<p>PPP协议应满足的需求：</p>
<ol>
<li><strong>简单</strong>。<br/> <br/><br>   互联网体系结构最复杂的部分是TCP协议，其次是IP网络协议，IP协议提供不可靠的数据报服务。<br/> <br/><br>   在此基础上数据链路层没必要提供多于IP协议的功能。<br/> <br/><br>   数据链路层协议: 接收方每收到一个帧，就进行CRC检验。如果CRC检验正确，就收下这个帧；反之，丢弃此帧。<br/> <br/></li>
<li><strong>封装成帧</strong><br/> <br/><br>   PPP协议必须规定特殊的字符作为帧定界符(SOH EOT)，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。<br/> <br/></li>
<li><strong>透明性</strong><br/> <br/><br>   PPP协议必须保证数据传输的透明性。<br/> <br/></li>
<li><strong>多种网络层协议</strong><br/> <br/><br>   PPP协议必须能够在<strong>同一条物理链路上同时支持多种网络层协议</strong>的运行。<br/> <br/></li>
<li><strong>多种类型链路</strong><br/> <br/><br>   PPP协议必须能够在多种类型的链路上运行。<br/> <br/></li>
<li><strong>差错检测(error detection)</strong><br/> <br/><br>   PPP协议必须能够对接收端收到的帧进行检测，并<strong>立刻丢弃有差错的帧</strong>。<br/> <br/></li>
<li><strong>检测链接状态</strong><br/> <br/><br>   PPP协议必须具有一种机制能够及时自动检测出链路是否处于正常工作状态。<br/> <br/></li>
<li><strong>最大传送单元</strong><br/> <br/><br>   PPP协议必须对每一种类型的点对点链路设置<strong>最大传送单元MTU</strong>的标准默认值。<br/> <br/><br>   如果高层协议发送的分组长度超过MTU的数值，PPP就要丢弃这样的帧，并返回差错。<br/> <br/><br>   MTU是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，不是<strong>帧的总长度</strong>。<br/> <br/></li>
<li><strong>网络层地址协商</strong><br/> <br/><br>   PPP协议必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络地址。<br/> <br/></li>
<li><strong>数据压缩协商</strong><br/> <br/><br>   PPP协议必须提供一种方法协商来使用数据压缩算法。<br/> <br/></li>
</ol>
<p>PPP协议只支持全双工链路。<br/> <br/></p>
<p><img src="/../images/network/frameformat.png" alt="PPP帧的格式"></p>
<p>PPP帧的首部和尾部分别为四个字段和两个字段。</p>
<p>首部的第一个字段和尾部的第二个字段都是<strong>标志字段F(Flag)<strong>，规定为</strong>0x7E</strong>，即二进制的01111110。标志字段表示一个帧的开始或结束，即PPP帧的定界符。</p>
<p>首部中的<strong>地址字段A</strong>规定为<strong>0xFF</strong>，即二进制的11111111。</p>
<p>首部中的<strong>控制字段C</strong>规定为<strong>0x03</strong>，即二进制的00000011。</p>
<p>首部中的第四个字段是2字节的<strong>协议字段</strong>。当协议字段为<strong>0x0021</strong>时，PPP帧的信息字段就是<strong>IP数据报</strong>。若为<strong>0xC021</strong>，信息字段是<strong>PPP协议链路控制协议LCP的数据</strong>。若为<strong>0x8021</strong>，信息字段是<strong>网络层的控制数据</strong>。</p>
<p>信息字段的长度是可变的，不超过1500字节(MTU)。</p>
<p>尾部中第一个字段(2字节)，是使用CRC检验的帧检验序列FCS。</p>
<p>当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须要采取一些措施使得这种形式上和标志字符一样的比特组合不出现在信息字段中。</p>
<p>当PPP使用<strong>异步传输(逐个字符地传送)</strong> 时，它把 <strong>转义符</strong>定义为<strong>0x7D</strong>，即二进制的01111101，并使用<strong>字节填充</strong>。填充方法如下：</p>
<ol>
<li>把信息字段中出现的每一个0x7E转变为2字节序列(0x7D,0x5E)。<br/> <br/></li>
<li>若信息字段中出现一个0x7D的字节，则把0x7D转变成为2字节序列(0x7D,0x5D)。<br/> <br/></li>
<li>若信息字段中出现ASCII码中的控制字符，即小于0x20的字符，则在该字符前加入0x7D字节，同时改变该字符的编码。<br/> <br/></li>
</ol>
<p>当PPP协议用在SONET&#x2F;SDH链路时，使用<strong>同步传输(一连串的比特连续发送)<strong>。在这种情况下，PPP协议采用</strong>零比特填充</strong>方法来实现透明传输，具体做法如下：</p>
<p><img src="/../images/network/zeropadding.png" alt="零比特填充"></p>
<ol>
<li>在发送端，扫描整个信息字段，只要发现有连续5个1，则立刻填入一个0。<br/> <br/></li>
<li>接收端在接收到一个帧时，先找到标志字段F以确定一个帧的边界，接着对比特流进行扫描。<br/> <br/></li>
<li>每发现5个连续的1时，删除后续的一个0，以还原成原来的信息比特流。<br/> <br/></li>
</ol>
<p><img src="/../images/network/PPPstatus.png" alt="PPP协议的状态图"></p>
<ol>
<li>用户拨号接入ISP，建立从用户个人电脑到ISP的物理连接。<br/> <br/></li>
<li>用户个人电脑向ISP发送一系列的链路控制协议LCP分组(封装成多个PPP帧)，以便建立LCP连接。<br/> <br/></li>
<li>进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。<br/> <br/></li>
<li>用户通信完毕，NCP释放网络层连接，收回原来分配的IP地址。<br/> <br/></li>
<li>LCP释放数据链路层连接。<br/> <br/></li>
<li>释放物理层的连接。<br/> <br/></li>
</ol>
<p>PPP链路的起始状态和终止状态永远是<strong>链路静止</strong>(Link Dead)状态，这时在用户个人电脑和ISP的路由器之间并不存在物理层的连接。</p>
<p>当用户个人电脑通过调制解调器呼叫路由器时，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP就进入<strong>链路建立</strong>(Link Establish)状态，目的是建立链路层的LCP连接。</p>
<p>LCP在建立连接后，开始协商一些<strong>配置选项</strong>，即发送LCP的<strong>配置请求帧</strong>(Configure-Request)。这也是一个PPP帧，其首部的协议字段置为LCP对应的代码(0xC021)，而信息字段包含特定的配置请求。连路的另一端可以发送的响应有：</p>
<ol>
<li><strong>配置确认帧</strong>(Configure-Ack) 所有选项都接受。<br/> <br/></li>
<li><strong>配置否认帧</strong>(Configure-Nak) 所有选项都理解但不能接受。<br/> <br/></li>
<li><strong>配置拒绝帧</strong>(Configure-Reject) 所有选项有的无法识别或不能接受，需要协商。<br/> <br/></li>
</ol>
<p>LCP配置选项包括链路上的最大帧长，所使用的<strong>鉴别协议</strong>(authentication protocol)的规约，以及不使用PPP帧中的地址和控制字段。</p>
<p>协商结束后双方建立起了LCP链路，接着进入<strong>鉴别</strong>(Authenticate)状态。在这一状态，只允许传送LCP协议的分组，鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议PAP</strong>(Password Authentication Protocol)，则需要发起通信的一方发送身份标识符和口令。系统允许用户重试若干次，如果需要有更好的安全性，则可使用更复杂的<strong>口令握手鉴别协议CHAP</strong>(Challenge-Handshake Authentication Protocol)。若鉴定身份失败，则转到<strong>链路终止</strong>(Link Terminate)状态。若鉴别成功，则进入<strong>网络层协议</strong>(Network-Layer Protocol)状态。</p>
<p>在<strong>网络层协议</strong>状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议相互交换网络层特定的网络控制分组，即PPP协议两端网络层可以运行不同的网络层协议，但仍然可以使用同一个PPP协议进行通信。</p>
<p>如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块时就要使用NCP中支持IP的协议-<strong>IP控制协议IPCP</strong>(IP Control Protocol)。IPCP分组也封装成PPP帧(帧的首部协议字段为0x8021)在PPP链路上传送。</p>
<p>当网络层配置完毕后，链路就进入可进行数据通信的<strong>链路打开</strong>(Link Open)状态。链路的连个PPP端点可以彼此向对方发送分组。两个PPP端点还可以发送<strong>回送请求</strong>LCP分组(Echo-Request)和<strong>回送回答</strong>LCP分组(Echo-Reply)，以检查链路的状态。</p>
<p>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong>LCP分组(Terminate-Request)请求终止链路连接，在收到对方发送的<strong>终止确认</strong>LCP分组(Terminate-Ack)后，转到<strong>链路终止</strong>状态。如果链路出现故障，也会从<strong>链路打开</strong>状态转到<strong>链路终止</strong>状态。当调制解调器的载波停止后，则回到<strong>链路静止</strong>状态。</p>
<h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p>广播信道可以进行一对多的通信。</p>
<h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><p>局域网最主要的特点是<strong>网络为一个单位所拥有，且地理范围和站点数目均有限</strong>。</p>
<p>局域网具有如下优点：</p>
<ol>
<li>具有广播功能，从一个站点可很方便的访问全网。局域网的主机可共享连接在局域网上的各种硬件和软件资源。<br/> <br/></li>
<li>便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变。<br/> <br/></li>
<li>提高了系统的可靠性，可用性和生存性。</li>
</ol>
<p><img src="/../images/network/WLANcls.png" alt="局域网的拓扑"></p>
<p>局域网按照<strong>网络拓扑</strong>分类，可分为星形网，环形网和总线网。</p>
<p><strong>星形网</strong>的出现是因为<strong>集线器</strong>(hub)的出现和双绞线的大量应用。</p>
<p><strong>环形网</strong>和<strong>总线网</strong>的各站直连在总线上。总线两端的匹配电阻吸收再总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。</p>
<p>局域网可使用多种传输媒体，双绞线最便宜，是局域网中的主流传输媒体，但只能在10Mbit&#x2F;s至10Gbit&#x2F;s上使用。在数据率比较高时，往往需要使用光纤作为传输媒体。</p>
<p>共享信道技术上实现众多用户合理而方便的使用共享信道媒体资源有两种方法：</p>
<ol>
<li><p><strong>静态划分信道</strong><br/> <br/><br>频分复用，时分复用，波分复用，码分复用都在此列。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方式代价较高，不适合局域网使用。<br/> <br/></p>
</li>
<li><p><strong>动态媒体接入控制</strong>，又称<strong>多点接入</strong>(multiple access)<br/> <br/><br>特点是信道并非在用户通信是固定分配给用户。<br/> <br/></p>
<ol>
<li><strong>随机接入</strong><br/> <br/><br>随机接入的特点是所有的用户可随机地发送信息。<br/> <br/><br>但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生<strong>碰撞</strong>，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。<br/> <br/></li>
<li><strong>受控接入</strong><br/> <br/><br>受控接入的特点是用户不能随机地发送信息而必须服从一定的控制。<br/> <br/><br>这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>(polling)或称为<strong>轮询</strong>。<br/> <br/></li>
</ol>
</li>
</ol>
<blockquote>
<p>传统以太网用来称呼最早流行的10Mbit&#x2F;s速率的以太网。<br>现今的以太网数据率已经演进到每秒吉比特乃至100吉比特。</p>
</blockquote>
<blockquote>
<p>为讨论原理，从传统以太网入手。</p>
</blockquote>
<h4 id="媒体接入控制MAC-Medium-Access-Control"><a href="#媒体接入控制MAC-Medium-Access-Control" class="headerlink" title="媒体接入控制MAC(Medium Access Control)"></a><strong>媒体接入控制MAC</strong>(Medium Access Control)</h4><p>由于历史原因，局域网802标准难以形成一个统一的局域网标准。为了使数据链路层能更好的适应多种局域网标准，局域网的数据链路层拆分为<strong>逻辑链路控制层LLC</strong>(Logical Link Control)和<strong>媒体接入控制MAC</strong>(Medium Access Control)。与接入媒体有关的内容都放在MAC子层，LLC子层与传输媒体无关。</p>
<p>在以太网占据局域网市场的垄断地位后，802标准被淘汰，使用DIX Ethernet V2标准。此时LLC的作用已经消失，厂商的适配器仅存在MAC协议。</p>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p><img src="/../images/network/adapter.png" alt="计算机通过适配器和局域网进行通信"></p>
<p>计算机和外界局域网的链接是通过通信<strong>适配器</strong>(adapter)实现的。</p>
<p>原本计算机仅有PCMCIA卡，又称<strong>网络接口卡NIC</strong>(Network Interface Card)，简称<strong>网卡</strong>。现今适配器已经集成到计算机主板上。这种适配器上装有处理器和存储器(RAM和ROM)。</p>
<p>适配器和局域网之间的通信是通过电缆或双绞线以串行运输方式进行的，而适配器和计算机之间的通信则是通过计算机主板的I&#x2F;O总线以并行运输方式进行的。因此适配器的一个重要功能是进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。</p>
<p>在主板插入适配器时，必须把管理该适配器的设备驱动程序安装在计算机操作系统中。这个驱动程序会告诉适配器额，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送的数据块存储下来。</p>
<p>适配器还需要能够实现以太网协议。</p>
<p>适配器在接收和发送各种帧时，不使用计算机的CPU。这时计算机中的CPU可以处理其他任务。</p>
<p>当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。</p>
<p>当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p>
<blockquote>
<p>计算机的硬件地址在适配器的ROM中，计算机的软件地址-IP地址在计算机的存储器中。</p>
</blockquote>
<h3 id="CSMA-x2F-CD-协议"><a href="#CSMA-x2F-CD-协议" class="headerlink" title="CSMA&#x2F;CD 协议"></a>CSMA&#x2F;CD 协议</h3><p>最早的以太网是将许多计算机都连接到一根总线上。当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据，即广播通信。</p>
<p>为了在总线上实现一对一通信，可以使每一台计算机的适配器拥有一个与其他适配器都不同的地址。在发送数据帧时，在帧的首部写明接收站的地址。</p>
<p>仅在数据帧中的目的地址与适配器ROM中存放的硬件地址一致时，该适配器才能接收这个数据帧。适配器不是发送给自己的数据帧就丢弃。</p>
<blockquote>
<p>局域网上的计算机也称为主机，工作站，站点，站。</p>
</blockquote>
<p>为了通信的简便，以太网采取了以下两种措施：</p>
<ol>
<li>采用较为灵活的<strong>无连接</strong>的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确认</strong>。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。<br/> <br/><br>当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。<strong>对有差错的帧是否需要重传则由高层决定</strong>。<br/> <br/><br>在总线上，只要有一台计算机在发送数据，总线的传输资源就被占用。<strong>在同一时间只能允许一台计算机发送数据</strong>，否则各计算机之间就会互相干扰，使得所发送的数据被破坏。<br/> <br/><br>以太网采用最简单的随机接入，但有很好的协议用来减少冲突发生的概率，即<strong>CSMA&#x2F;CD</strong>，**载波监听多点接入&#x2F;碰撞检测(Carrier Sense Multiple Access with Collision Detection)**。<br/> <br/></li>
<li>以太网发送的数据都使用<strong>曼彻斯特(Manchester)编码</strong>。<br/> <br/><br>曼彻斯特编码的编码方法是把每一个码元再分成两个相等的间隔。码元1是前一个间隔为低电压而后一个间隔为高电压。码元0正好相反，从高电压到低电压。也可以采用相反的约定。<br/> <br/><br>但这样的操作会使得所占频带宽度会比原始的基带信号增加一倍。</li>
</ol>
<h4 id="CSMA-x2F-CD协议要点"><a href="#CSMA-x2F-CD协议要点" class="headerlink" title="CSMA&#x2F;CD协议要点"></a>CSMA&#x2F;CD协议要点</h4><p><strong>多点接入</strong>说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</p>
<p>协议的实质是<strong>载波监听</strong>和<strong>碰撞检测</strong>。</p>
<p><strong>载波监听</strong>是用电子技术检测总线上是否有正在发送的数据。它在检测信道。不管在发送前，还是发送中，每个站都必须不停地检测信道。</p>
<p>在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。</p>
<p>在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞，即碰撞检测。</p>
<p><strong>碰撞检测</strong>即<strong>边发送边监听</strong>。适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</p>
<p>当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大(互相叠加)。当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，产生了碰撞。此时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息。因此，任何一个正在发送数据的站一但发现总线上出现了碰撞，其适配器就要立刻停止发送，免得继续进行无效的发送，浪费网络资源，然后等待一段随机时间后再次发送。</p>
<p><img src="/../images/network/collision.png" alt="传播时延对载波监听的影响"></p>
<p>设图中的局域网两端的站A和B相距1km，用同轴电缆相连。</p>
<blockquote>
<p>电磁波在1km电缆的传播时延约为<strong>5微秒</strong>。</p>
</blockquote>
<p>A向B发出的数据，约在5微秒后才能传送到B。B若在A发送的数据到达B之前发送自己的帧，则必然要在某个时间和A发送的帧发生碰撞。</p>
<p>假设总线上<strong>单程端到端传播时延</strong>为$ \tau $。</p>
<p>A在发送数据后，最迟要经过<strong>两倍的总线端到端的传播时延($ 2\tau $)</strong> 才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。</p>
<p>由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延(距离最大的两个站)为端到端传播时延。</p>
<p>显然，在使用CSMA&#x2F;CD协议时，一个站<strong>不可能同时进行发送和接收(但必须边发送边监听信道)<strong>。因此，使用CSMA&#x2F;CD协议的以太网不可能进行全双工通信，只能进行</strong>双向交替通信&#x2F;半双工通信</strong>。</p>
<ol>
<li><p>在$ t&#x3D;0 $时，A发送数据。B检测到信道为空闲。</p>
</li>
<li><p>在$ t &#x3D; \tau - \delta, \tau &gt; \delta &gt; 0 $时，A发送的数据还没有到达B时，由于B检测到信道是空闲的，因此B发送数据。</p>
</li>
<li><p>经过时间$ \delta &#x2F; 2 $后，即在$ t &#x3D; \tau - \delta &#x2F; 2 $时，A发送的数据和B发送的数据发生了碰撞。但这时A和B都不知道发生了碰撞。</p>
</li>
<li><p>在$ t &#x3D; \tau $时，B检测到发生了碰撞，于是停止发送数据。</p>
</li>
<li><p>在$ t &#x3D; 2\tau - \delta $时，A也检测到发生了碰撞，因此也停止发送数据。</p>
</li>
<li><p>A和B发送数据均失败，他们都要推迟一段时间再重新发送。</p>
</li>
</ol>
<p><strong>每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定</strong>的，它取决于另一个发送数据的站到本站的距离。因此，以太网不能保证某一时间之内一定能够把自己的数据帧成功地发送出去。这一特点称为以太网的<strong>发送的不确定性</strong>。</p>
<p>要使在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</p>
<p>最先发送数据帧的A站，在发送数据帧后<strong>至多</strong>经过时间$ 2\tau $就能够知道所发送的数据帧是否遭受到了碰撞。这是$ \delta → 0 $的情况。因此，以太网的端到端往返时间$ 2\tau $称为**争用期(contention period)&#x2F;碰撞窗口(collision window)**。</p>
<p>以太网使用**截断二进制指数退避(truncated binary exponential backoff)**算法来确定碰撞后重传的时机。</p>
<p>在发生碰撞后，该算法让站在停止发送数据后，不是等待信道变为空闲后就立刻再发送数据，而是<strong>推迟&#x2F;退避</strong>一个随机的时间。</p>
<p>具体的退避算法如下：<br/> <br/></p>
<ol>
<li>协议规定了基本退避时间为争用期$ 2\tau $，具体的争用期时间是51.2微秒。对于10Mbit&#x2F;s以太网，在争用期内可发送512bit，即64字节。也可以说争用期是512比特时间。<br/> <br/></li>
<li>从离散的整数集合$ [0,1,\cdots,(2^k-1)] $中随机取出一个数，记为r。重传应推后的时间就是r倍的争用期。上面的参数k按$ 式 \eqref{eq:one} $计算：<br/> <br/><br>$$ k&#x3D;Min[重传次数,10] \tag{1} \label{eq:one}$$<br>可见当重传次数不超过10时，参数k等于重传次数；但当重传次数超过10时，k就不再增大而一直等于10。</li>
<li>当重传次数达到16次仍不能成功时，则丢弃此帧，并向高层报告。</li>
</ol>
<p><a href="https://blog.csdn.net/jasonchen_gbd/article/details/80170309">为什么要考虑这种情况？</a>现考虑一种情况，某个站发送了一个很短的帧。但在发送完毕之前并没有检测出碰撞。假定这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了碰撞，因而目的站将收到这个有差错的帧，并丢弃。可是发送站不知道这个帧发生了碰撞，因而不会重传这个帧。为避免发生这种情况，以太网规定了一个最短帧长64字节。如果发送的数据非常少，必须加入填充字节，使得帧长不小于64字节。</p>
<p>以上，以太网在发送数据时，如果在争用期没有发生碰撞，那么后续发送的数据就一定不会发生冲突。也就是说，如果发生碰撞，一定是在发送的前64字节内。</p>
<p>由于一检测到冲突就立刻中止发送，这时已经发送出去的数据一定小于64字节，因此，<strong>长度小于64字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到这种无效帧，就应当立即将其丢弃。</p>
<p>以太网的争用期确定为51.2微秒，不仅考虑到以太网的端到端时延，而且还包括其他的许多因素，例如存在的转发器所增加的时延，以及强化碰撞的干扰信号的持续时间。</p>
<p><strong>强化碰撞</strong>是指当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要继续发送32bit&#x2F;48bit的**人为干扰信号(jamming signal)**，以便让所有用户都知道现在已经发生了碰撞。</p>
<p><img src="/../images/network/jamming.png" alt="人为干扰信号的加入"></p>
<blockquote>
<p>B站得知发生碰撞后也要发送人为干扰信号，忽略。</p>
</blockquote>
<p>A站从发送数据开始到发现碰撞并停止发送的时间间隔是$ T_B $。A站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是$ T_J $。发生碰撞使A浪费时间$ T_B + T_J $。可是整个信道被占用的时间还要增加一个单程端到端时延$ \tau $。因此，总线被占用的时间是$ T_B + T_J + \tau $。</p>
<p>以太网还规定了<strong>帧间最小间隔</strong>为9.6微秒。相当于96比特时间。这样做是使得刚接收数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
<p>CSMA&#x2F;CD协议的要点归纳如下：</p>
<ol>
<li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。<br/> <br/></li>
<li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲，若检测到信道空闲，并在96bit时间内信道保持空闲(帧间最小间隔)，就发送这个帧。<br/> <br/></li>
<li>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。这里只有两种可能性：<br/> <br/><ol>
<li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，什么也不做，返回第1步。<br/> <br/></li>
<li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待r倍512比特时间后，返回第2步，继续监测信道。若重传16次仍不能成功，则停止重传而向上报错。</li>
</ol>
</li>
</ol>
<p>以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么在推迟一段时间后再把这个暂时保留的帧重传一次。</p>
<h3 id="使用集线器的星型拓扑"><a href="#使用集线器的星型拓扑" class="headerlink" title="使用集线器的星型拓扑"></a>使用集线器的星型拓扑</h3>]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 239. 滑动窗口最大值</title>
    <url>/leetcode/239.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="单调队列-N-x2F-A"><a href="#单调队列-N-x2F-A" class="headerlink" title="单调队列 N&#x2F;A"></a>单调队列 N&#x2F;A</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span><br><span class="line">    queue, ret = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> queue[-<span class="number">1</span>] &lt; nums[i]: queue.pop()</span><br><span class="line">        queue.append(nums[i])</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> nums[i - k] == queue[<span class="number">0</span>]:</span><br><span class="line">                queue.pop(<span class="number">0</span>)</span><br><span class="line">            ret.append(queue[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="修改单调队列格式"><a href="#修改单调队列格式" class="headerlink" title="修改单调队列格式"></a>修改单调队列格式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span><br><span class="line">    queue, ret = collections.deque(), []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> queue[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">            queue.pop()</span><br><span class="line">        queue.append(nums[i])</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> nums[i - k] == queue[<span class="number">0</span>]:</span><br><span class="line">                queue.popleft()</span><br><span class="line">            ret.append(queue[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># print(queue)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 238. 除自身以外数组的乘积</title>
    <url>/leetcode/238.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">nums</span>):</span><br><span class="line">    nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line">    left = [<span class="number">1</span>] * nums_len</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nums_len):</span><br><span class="line">        left[i] = left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(left)</span></span><br><span class="line">    right = [<span class="number">1</span>] *nums_len</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums_len - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        right[i] = right[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(right)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums_len):</span><br><span class="line">        left[i] = left[i] * right[i]</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 236. 二叉树的最近公共祖先</title>
    <url>/leetcode/236.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="递归1"><a href="#递归1" class="headerlink" title="递归1"></a>递归1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ret = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment"># 后序遍历</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">            left = order(root.left)</span><br><span class="line">            right = order(root.right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> (left, root, right) <span class="keyword">and</span> q <span class="keyword">in</span> (left, root, right):</span><br><span class="line">                self.ret = root</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> p <span class="keyword">in</span> (left, root, right):</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            <span class="keyword">elif</span> q <span class="keyword">in</span> (left, root, right):</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        order(root)</span><br><span class="line">        <span class="keyword">return</span> self.ret</span><br></pre></td></tr></table></figure>

<h1 id="递归2"><a href="#递归2" class="headerlink" title="递归2"></a>递归2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">root, p, q</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root</span><br><span class="line">    left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 234. 回文链表</title>
    <url>/leetcode/234.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">digui</span>(<span class="params">s, e</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> e: <span class="keyword">return</span> s, <span class="literal">True</span></span><br><span class="line">        s, ret = digui(s, e.<span class="built_in">next</span>)</span><br><span class="line">        ret = ret <span class="keyword">and</span> s.val == e.val</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">next</span>, ret</span><br><span class="line">    _, ret = digui(head, head)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 226. 翻转二叉树</title>
    <url>/leetcode/226.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line">    root.left, root.right = root.right, root.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 221. 最大正方形</title>
    <url>/leetcode/221.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maximalSquare</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> ret ** <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 215. 数组中第K个最大元素</title>
    <url>/leetcode/215.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="无脑解法-根本思想是排序解决"><a href="#无脑解法-根本思想是排序解决" class="headerlink" title="无脑解法,根本思想是排序解决"></a>无脑解法,根本思想是排序解决</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>):</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

<h1 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="comment"># 以大顶堆实现</span></span><br><span class="line">    nums_len= <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建堆处理</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nums_len):</span><br><span class="line">        <span class="comment"># 父节点</span></span><br><span class="line">        j = (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i, j = j, (j - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="comment"># 堆排序</span></span><br><span class="line">    nums_len -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[nums_len] = nums[nums_len], nums[<span class="number">0</span>]</span><br><span class="line">        nums_len -= <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= nums_len:</span><br><span class="line">            l, r, i = <span class="number">2</span> * j + <span class="number">1</span>, <span class="number">2</span> * j + <span class="number">2</span>, j</span><br><span class="line">            <span class="keyword">if</span> l &lt;= nums_len <span class="keyword">and</span> nums[l] &gt; nums[i]:</span><br><span class="line">                i = l</span><br><span class="line">            <span class="keyword">if</span> r &lt;= nums_len <span class="keyword">and</span> nums[r] &gt; nums[i]:</span><br><span class="line">                i = r</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                j = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 208. 前缀树</title>
    <url>/leetcode/208.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.tree = Tree(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        tree = self.tree</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> tree.<span class="built_in">next</span>.keys():</span><br><span class="line">                tree.<span class="built_in">next</span>[w] = Tree(w)</span><br><span class="line"></span><br><span class="line">            tree = tree.<span class="built_in">next</span>[w]</span><br><span class="line">        tree.<span class="built_in">next</span>[-<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        tree = self.tree</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> tree.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            tree = tree.<span class="built_in">next</span>[w]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tree.<span class="built_in">next</span>.get(-<span class="number">1</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        tree = self.tree</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> tree.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            tree = tree.<span class="built_in">next</span>[w]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 207. 课程表</title>
    <url>/leetcode/207.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>把课程看作图中的节点，所有所需学习的课程构成有向图，问题转化为查看图是否是有向无环图。</p>
<p>拓扑排序: 对有向无环图的顶点进行排序，使得每一条有向边均有边起点定点在有向边终点之前。</p>
<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canFinish</span>(<span class="params">numCourses, prerequisites</span>):</span><br><span class="line">    <span class="comment"># 入度表和邻接表</span></span><br><span class="line">    indeg, adj = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)], [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">    <span class="comment"># 构建入度表和有向图邻接表</span></span><br><span class="line">    <span class="keyword">for</span> e, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">        indeg[e] += <span class="number">1</span></span><br><span class="line">        adj[s].append(e)</span><br><span class="line">    <span class="comment"># 查找入度为0的节点</span></span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(indeg)):</span><br><span class="line">        <span class="keyword">if</span> indeg[i] == <span class="number">0</span>:</span><br><span class="line">            queue.append(i)</span><br><span class="line">    <span class="comment"># bfs</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        s = queue.popleft()</span><br><span class="line">        numCourses -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> adj[s]:</span><br><span class="line">            indeg[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> indeg[i] == <span class="number">0</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canFinish</span>(<span class="params">numCourses, prerequisites</span>):</span><br><span class="line">    <span class="comment"># 邻接表</span></span><br><span class="line">    adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">    <span class="comment"># 构建有向图邻接表</span></span><br><span class="line">    <span class="keyword">for</span> e, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">        adj[s].append(e)</span><br><span class="line">    flags = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dfs</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, flags, adj</span>):</span><br><span class="line">        <span class="keyword">if</span> flags[i] == -<span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> flags[i] == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        flags[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> adj[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(j, flags, adj): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        flags[i] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dfs(i, flags, adj): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
        <tag>队列</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库 1</title>
    <url>/books/sql_1.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>SQL: Structured Query Language</p>
<p>RDBMS: Relational Database Management System</p>
</blockquote>
<h1 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h1><ol>
<li>查看数据库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use your_database_name;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置使用的字符集</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> names utf-8;</span><br></pre></td></tr></table></figure>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>用于从数据库中选取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.</span></span><br><span class="line">select * </span><br><span class="line">from table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.</span></span><br><span class="line">select column_name, column_name </span><br><span class="line">from table_name;</span><br></pre></td></tr></table></figure>
<h1 id="select-distinct"><a href="#select-distinct" class="headerlink" title="select distinct"></a>select distinct</h1><p>用于返回唯一不同的值(去重子集)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select distinct column_name, column_name </span><br><span class="line">from table_name;</span><br></pre></td></tr></table></figure>

<h1 id="where"><a href="#where" class="headerlink" title="where"></a>where</h1><p>用于过滤记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select column_name, column_name </span><br><span class="line">from table_name </span><br><span class="line"><span class="built_in">where</span> column_name operator value;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;&#x2F;!&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">between</td>
<td align="center">在某个范围内</td>
</tr>
<tr>
<td align="center">like</td>
<td align="center">搜索某种模式</td>
</tr>
<tr>
<td align="center">in</td>
<td align="center">指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
<h1 id="and-x2F-or"><a href="#and-x2F-or" class="headerlink" title="and &#x2F; or"></a>and &#x2F; or</h1><p>用于基于一个以上的条件对记录进行过滤</p>
<p>如果所有条件都成立，and运算符显示一条记录。</p>
<p>如果有一个条件成立，or运算符显示一条记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select * </span><br><span class="line">from table_name</span><br><span class="line"><span class="built_in">where</span> column_name operator value </span><br><span class="line">or / and column_name operator value;</span><br></pre></td></tr></table></figure>

<h1 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h1><p>用于对结果集进行排序</p>
<p>对结果集按照一个列或者多个列进行排序。</p>
<p>默认按照升序对结果进行排序。</p>
<p>需要按照降序排列， 使用desc关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select column_name, column_name </span><br><span class="line">from table_name</span><br><span class="line">order by column_name, column_name asc / desc;</span><br></pre></td></tr></table></figure>

<h1 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h1><p>用于向表中插入新纪录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 无需指定要插入数据的列名,只需要提供被插入的值即可;</span></span><br><span class="line">insert into table_name</span><br><span class="line">values (value1, value2, ..., valuen);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 需要指定列名及被插入的值.</span></span><br><span class="line">insert into table_name (column1, column2, ..., columnn)</span><br><span class="line">values (value1, value2, ..., valuen);</span><br></pre></td></tr></table></figure>
<h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>用于更新表中已存在的记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update table_name</span><br><span class="line"><span class="built_in">set</span> column1=value1, column2=value2</span><br><span class="line"><span class="built_in">where</span> some_column = some_value;</span><br></pre></td></tr></table></figure>

<h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p>用于删除表中的记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete from table_name</span><br><span class="line"><span class="built_in">where</span> some_column=some_value;</span><br></pre></td></tr></table></figure>

<h1 id="select-top-x2F-limit-x2F-rownum"><a href="#select-top-x2F-limit-x2F-rownum" class="headerlink" title="select top &#x2F; limit &#x2F; rownum"></a>select top &#x2F; limit &#x2F; rownum</h1><p>select top </p>
<blockquote>
<p>select top是SQL Server使用的语句，并非所有数据库系统都支持。mysql支持limit</p>
</blockquote>
<h1 id="create-database"><a href="#create-database" class="headerlink" title="create database"></a>create database</h1><h1 id="alter-database"><a href="#alter-database" class="headerlink" title="alter database"></a>alter database</h1><h1 id="create-table"><a href="#create-table" class="headerlink" title="create table"></a>create table</h1><h1 id="alter-table"><a href="#alter-table" class="headerlink" title="alter table"></a>alter table</h1><h1 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h1><h1 id="create-index"><a href="#create-index" class="headerlink" title="create index"></a>create index</h1><h1 id="drop-index"><a href="#drop-index" class="headerlink" title="drop index"></a>drop index</h1>]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>校招</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 206. 反转链表</title>
    <url>/leetcode/206.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">    end = reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure>

<h1 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代 1"></a>迭代 1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">    pre, cur, nex = <span class="literal">None</span>, head, head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> nex:</span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre, cur, nex = cur, nex, nex.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = pre</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h1 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代 2"></a>迭代 2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">    pre, cur, nex = <span class="literal">None</span>, head, head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre, cur = cur, nex</span><br><span class="line">        <span class="keyword">if</span> nex: nex = nex.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>链表</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 200. 岛屿数量</title>
    <url>/leetcode/200.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; width <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; height <span class="keyword">or</span> grid[i][j] == <span class="string">&quot;0&quot;</span>: <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="string">&quot;0&quot;</span></span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">        dfs(grid,i - <span class="number">1</span>, j)</span><br><span class="line">        dfs(grid,i, j + <span class="number">1</span>)</span><br><span class="line">        dfs(grid,i, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    width, height = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dfs(grid, i, j)</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">        queue = [[i, j]]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                w, h = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= w &lt; width <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= h &lt; height <span class="keyword">or</span> grid[w][h] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append([w + <span class="number">1</span>, h])</span><br><span class="line">                queue.append([w - <span class="number">1</span>, h])</span><br><span class="line">                queue.append([w, h + <span class="number">1</span>])</span><br><span class="line">                queue.append([w, h - <span class="number">1</span>])</span><br><span class="line">                grid[w][h] = <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">    width, height = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            bfs(grid, i , j)</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 198. 打家劫舍</title>
    <url>/leetcode/198.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划方程"><a href="#动态规划方程" class="headerlink" title="动态规划方程"></a>动态规划方程</h1><p>状态转移: $ f(i) &#x3D; max(f(i - 2) + cur, f(i - 1)) $</p>
<p>初始化: $dp[0]&#x3D;0,dp[1]&#x3D;nums[0]$</p>
<h1 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        dp[i + <span class="number">1</span>] = <span class="built_in">max</span>(nums[i] + dp[i - <span class="number">1</span>],dp[i])</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="空间优化动态规划"><a href="#空间优化动态规划" class="headerlink" title="空间优化动态规划"></a>空间优化动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    ppre, pre, cur = <span class="number">0</span>, nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        cur = <span class="built_in">max</span>(nums[i] + ppre, pre)</span><br><span class="line">        ppre, pre = pre, cur</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试笔记 2</title>
    <url>/books/soft_test2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="软件测试-黑盒测试"><a href="#软件测试-黑盒测试" class="headerlink" title="软件测试 黑盒测试"></a>软件测试 黑盒测试</h1><p><strong>黑盒测试</strong>是一种软件测试技术，它可以检查软件的功能，而不会窥视其内部结构或编码。其主要来源是用户声明的要求规范。</p>
<p>在此方法中，测试人员选择一个函数并提供输入值以检查它的功能，并检查该函数是否给出了预期的输出。如果函数产生正确的输出，则在测试中传递，否则测试失败。测试团队将结果报告给开发团队，然后测试下一个功能。如果出现严重问题，在完成所有功能测试的测试后，会将测试结果返回给开发团队进行修正。</p>
<ol>
<li><p>黑盒测试基于要求的规范，因此在开始的时候进行检查。</p>
</li>
<li><p>测试人员通过选择有效和无效的输入值来检查软件是正确还是错误的处理它们，从而创建肯定的测试场景和不利的测试场景。</p>
</li>
<li><p>测试人员开发各种测试用例: 决策表，所有对测试，等效划分，误差估计，因果图等。</p>
</li>
<li><p>包括执行所有测试用例。</p>
</li>
<li><p>测试仪将预期输出与实际输出进行比较。</p>
</li>
<li><p>最后一步，如果软件中存在任何缺陷，则将其修复并再次测试。</p>
</li>
</ol>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>黑盒测试的测试过程是测试人员对软件工作有特定知识的一种过程，它开发测试用例以检查软件功能的准确性。</p>
<p>此过程不需要软件的编程知识。所有测试用例都是通过考虑特定函数的输入输出来设计的。测试人员知道特定输入的输出，但不知道结果是怎样产生的。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试用例是根据要求的规范创建的。测试用例通常是根据软件的工作描述创建的，包括要求，设计参数和其他规范。</p>
<p>对于测试，测试设计者通过采用有效输入值和不利测试场景来选择测试场景，方法是采用无效输入值来确定正确的输出。</p>
<p>测试用例主要用于功能测试，也可以用于非功能测试。</p>
<p>测试用例是由测试团队设计的，没有任何软件开发团队的参与。</p>
<h2 id="黑盒测试使用的技术"><a href="#黑盒测试使用的技术" class="headerlink" title="黑盒测试使用的技术"></a>黑盒测试使用的技术</h2><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">技术</th>
<th align="center">描述说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">决策表技术</td>
<td align="center">系统方法。以表的形式捕获各种输入组合及其各自的系统行为。适用于在两个或两个以上输入之间具有逻辑关系的函数。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">边界值问题技术</td>
<td align="center">用于测试边界值，边界值是包含变量上限和下限的边界值。在输入边界值时测试软件是否产生正确的输出。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">状态转换技术</td>
<td align="center">用于在向同一功能提供不同的输入值时捕获软件应用程序的行为。适用于那些提供访问应用程序的特定尝试次数的应用程序类型。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">成对测试技术</td>
<td align="center">用于测试所有可能的离散值组合。这种组合方法用于测试使用复选框，单选按钮输入，列表框，文本框等的应用程序。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">因果技术</td>
<td align="center">强调了给定结果与影响结果的所有因素之间的关系。基于一系列要求。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">等价类划分技术</td>
<td align="center">其输入数据被划分为有效值和无效值的分区，并且所有分区必须表现出相同的行为。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">错误猜测技术</td>
<td align="center">一种没有用于识别错误的特定方法的技术。基于测试分析师的经验，测试人员来猜测软件的有问题区域。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">用例技术</td>
<td align="center">用于根据系统的使用情况从系统的开头到结尾识别测试用例。通过这种技术，测试团队创建了一个测试场景，可以从头到尾根据每个功能的功能运行整个软件。</td>
</tr>
</tbody></table>
<h2 id="决策表技术"><a href="#决策表技术" class="headerlink" title="决策表技术"></a>决策表技术</h2><p>决策表技术是用于黑盒测试的用例设计技术之一，是一种系统方法，以表格形式捕获各种输入组合及其各自的系统行为。</p>
<p>决策表又称因果表，用于系统的选择测试用例，能够节省测试时间，并为软件应用程序的测试区域提供良好的覆盖。</p>
<p>决策表技术适用于在两个和两个以上输入之间具有逻辑关系的函数。</p>
<p>该技术与输入的正确组合有关，并确定各种输入组合的结果。要通过决策表技术设计测试用例，需要将条件视为输入，将操作视为输出。</p>
<p>在使用决策表技术时，测试人员确定预期输出，如果函数产生预期输出，则在测试中传递，如果不是，则失败。将失败的软件发送回开发团队以修复缺陷。</p>
<h2 id="边界值分析技术"><a href="#边界值分析技术" class="headerlink" title="边界值分析技术"></a>边界值分析技术</h2><p>边界值分析是用于黑盒测试用例设计技术之一。</p>
<p>边界值分析用于测试边界值，因为边界附近的输入值具有较高的误差机会。</p>
<p>边界值是包含变量上限和下限的值。</p>
<p>边界值的测试是通过制作有效和无效的分区来完成的。测试无效分区是因为在不利条件下测试输出也是必要的。</p>
<p>在使用边界值分析技术时，软件系统接收有效数字并提供所需的输出，则软件系统将在测试中传递。如果不是，则不成功。在另一种情况下，软件系统不应接受无效数字。如果输入的数字无效，则应显示错误信息。如果正在测试的软件遵循所有测试指南和规范，则将其发送给发布团队，否则发送给开发团队以修复缺陷。</p>
<h2 id="状态转化技术"><a href="#状态转化技术" class="headerlink" title="状态转化技术"></a>状态转化技术</h2><p>状态转换的一般意义是相同情况的不同形式，状态转换方法也是如此。</p>
<p>当不同的输入值赋予相同的函数时，它用于捕获软件应用程序的行为。</p>
<p>使用相同的函数，但每次输出不同时，称为状态转换。</p>
<p>在测试软件应用程序的情况下，此方法测试函数是否遵循进入不同输入的状态转换规范。适用于那些提供访问应用程序的特定尝试次数的应用程序类型。</p>
<h2 id="成对测试技术"><a href="#成对测试技术" class="headerlink" title="成对测试技术"></a>成对测试技术</h2><p>成对测试技术也称为配对测试。</p>
<p>适用于测试所有可能的离散值组合。</p>
<p>用于测试使用复选框输入，单选按钮输入的应用程序，列表框，文本框等。</p>
<h2 id="因果测试技术"><a href="#因果测试技术" class="headerlink" title="因果测试技术"></a>因果测试技术</h2><p>因果图来自黑盒测试技术，强调了给定结果与影响结果的所有因素之间的关系。用于编写动态测试实例。</p>
<p>当代码根据用户输入动态运行时，将使用动态测试用例。</p>
<p>因果图基于一系列需求，用于确定可覆盖软件最大测试区域的最小可能测试用例。</p>
<p>主要优点是减少了测试执行的时间和成本。</p>
<p>该技术旨在减少测试用例的数量，但仍覆盖所有必要的测试用例，覆盖范围大，以达到所需的应用程序质量。</p>
<p>因果图技术通过使用AND，OR和NOT等逻辑运算符将需求规范转换为输入和输出条件之间的逻辑关系。</p>
<p>在给定情况的因果图后，测试人员需要将原因和结果转换为逻辑语句，然后设计因果图。如果函数根据输入(原因)给出输出(效果)，则认为它是无缺陷，如果不这样做，则将其发送给开发团队指正。</p>
<p>步骤总结：</p>
<ol>
<li>画出效果和圆圈；</li>
<li>从效果开始，然后选择导致此效果的原因。</li>
<li>最后绘制相互排斥的原因(通过一种效应和一种原因直接连接的独占原因)。</li>
<li>使用逻辑门绘制动态测试用例。</li>
</ol>
<h2 id="等效分区技术"><a href="#等效分区技术" class="headerlink" title="等效分区技术"></a>等效分区技术</h2>]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>校招</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 169. 多数元素</title>
    <url>/leetcode/169.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="暴力hash解法"><a href="#暴力hash解法" class="headerlink" title="暴力hash解法"></a>暴力hash解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 假设只有两个数</span></span><br><span class="line">    save = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> save.keys():</span><br><span class="line">            save[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            save[num] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    save = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> save.items()&#125;</span><br><span class="line">    <span class="keyword">return</span> save[<span class="built_in">max</span>(save.keys())]</span><br></pre></td></tr></table></figure>

<h1 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 假设只有两个数</span></span><br><span class="line">    cand, count = nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> cand == num:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                cand, count = num, <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cand</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash表</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记 2</title>
    <url>/books/network_2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。需要尽可能屏蔽计算机网络中的硬件设备和传输媒体以及通信手段的不同，使得物理层上面的数据链路层感觉不到这些差异，让数据链路层只需要考虑如何完成本层的协议和服务，不必考虑网络具体的传输媒体和通信手段。</p>
<p>物理层<strong>规程</strong>(procedure)指物理层的协议。</p>
<p>物理层的主要任务是确定与传输媒体的借口有关的一些特性：</p>
<ol>
<li>机械特性: 指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等。</li>
<li>电气特性: 指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性: 指明某条线上出现的某一点评的电压的意义。</li>
<li>过程特性: 指明对于不同功能的各种可能事件的出现顺序。</li>
</ol>
<h2 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h2><p>   数据通信系统可划分为三部分: 源系统&#x2F;发送端&#x2F;发送方，传输系统&#x2F;传输网络，目的系统&#x2F;接收端&#x2F;接收方。</p>
<p>   <img src="/../images/network/data_system.png" alt="数据通信系统的模型"></p>
<ol>
<li><p>源系统</p>
<p>源系统一般包括两个部分，<strong>源点&#x2F;源站&#x2F;信源</strong>(source)和<strong>发送器</strong>。</p>
<ul>
<li>源点: 源点设备产生要传输的数据。</li>
<li>发送器: 通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。</li>
</ul>
</li>
<li><p>目的系统<br>目的系统一般包括两个部分，<strong>接收器</strong>和<strong>终点&#x2F;目的站&#x2F;信宿</strong>(destination)。</p>
<ul>
<li>接收器: 接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。</li>
<li>终点: 终点设备从接收器获取传送来的数字比特流，把信息输出。</li>
</ul>
</li>
</ol>
<p>   在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目标系统之间的复杂网络系统。</p>
<blockquote>
<p>通信的目的是传送<strong>消息</strong>(message)。</p>
<p><strong>数据</strong>(data)是运送消息的实体。其严格定义为是使用特定方式表示的信息，通常是有异议的符号序列。</p>
<p><strong>信号</strong>(signal)则是数据的电气或电磁的表现。</p>
</blockquote>
<p>信号可分为<strong>模拟信号</strong>和<strong>数字信号</strong>:</p>
<ol>
<li>模拟信号&#x2F;连续信号: 消息参数的取值是连续的。</li>
<li>数字信号&#x2F;离散信号: 消息参数的取值是离散的。代表不同离散数值的基本波形成为<strong>码元</strong>。</li>
</ol>
<blockquote>
<p><strong>信道</strong>(channel)一般用来表示向某一个方向传送信息的媒体。</p>
</blockquote>
<p>从通信的双方信息交互的方式来看，有三种基本方式: <strong>单向通信&#x2F;单工通信</strong>，<strong>双向交替通信&#x2F;半双工通信</strong>和<strong>双向同时通信&#x2F;全双工通信</strong>。</p>
<ol>
<li>单向通信: 只能有一个方向的通信而没有反方向的交互，eg: 无线广播，电视。</li>
<li>双向交替通信: 通信的双方都可以发送信息，但不能双方同时发送&#x2F;同时接收。这种通信方式是一方发送另一方接收，过一段时间后反向工作。</li>
<li>双向同时通信: 通信的双方可以同时发送和接收信息。</li>
</ol>
<h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><blockquote>
<p>来自信源的信号称为基带信号(基本频带信号)。</p>
</blockquote>
<p>基带信号往往包含有较多的低频成分，甚至有直流成分，而很多信道并不能传输这种低频分量或直流分量。</p>
<p>为了解决这一问题，就必须对基带信号进行<strong>调制</strong>(modulation)。</p>
<p>调制可分为两大类:<strong>基带调制</strong>和<strong>带通调制</strong>。</p>
<ol>
<li><p>基带调制: 仅仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍是基带信号。</p>
<p>这种基带调制是把数字信号转换为另一种形式的数字信号，又称为<strong>编码</strong>(coding)。</p>
</li>
<li><p>带通调制: 使用<strong>载波</strong>(carrier)的调制。把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。</p>
<p> 经过载波调制后的信号成为<strong>带通信号</strong>，即仅在一段频率范围内能够通过信道。</p>
</li>
</ol>
<h3 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h3><p><img src="/../images/network/coding_type.png" alt="数字信号常用的编码方式"></p>
<ol>
<li>不归零制: 正电平代表1，负电平代表0。</li>
<li>归零制: 正脉冲代表1，负脉冲代表0。</li>
<li>曼彻斯特编码: 位周期中心的向上跳变代表0，为周期中心的向下跳变代表1，但也可以反过来定义。</li>
<li>差分曼彻斯特编码: 在每一位中心处始终都有跳变。位开始边界有跳变代表0， 而位开始边界没有跳变代表1。</li>
</ol>
<p>从信号波形看，曼彻斯特(Manchester)编码产生的信号频率比不归零高。</p>
<p>从自同步能力看，不归零制不能从信号波形本身中提取信号时钟频率，即没有自同步能力，而曼彻斯特编码具有自同步能力。</p>
<h3 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h3><p><img src="/../images/network/cattier_type.png" alt="最基本的三种调制方法"></p>
<ol>
<li>调幅(AM): 载波的振幅随基带数字信号而变化。</li>
<li>调频(FM): 载波的频率随基带数字信号而变化。</li>
<li>调相(PM): 载波的初始相位随基带数字信号而变化。</li>
</ol>
<p>为了达到更多的信息传输速率，必须技术上采用更复杂的多元制的振幅相位混合调制方法，eg:<strong>正交振幅调制</strong>(Quadrature Amplitude Modulation)。</p>
<h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>数字通信的优点: 虽然信号在信道上传输时会不可避免的失真，但在只要在接收端从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。</p>
<p>码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量差，在接收端的波形失真就越严重。</p>
<p>从概念上讲，限制码元在信道上的传输速率的因素有两个:</p>
<ol>
<li><p>信道能够通过的频率范围<br>具体的信道所能通过的频率范围总是有限的，信号中的许多高频分量往往不能通过信道。</p>
<blockquote>
<p>码间串扰: 信号中的高频分量在传输时受到衰减，在接收端收到的波形前沿和后沿就变得不陡峭了，每一个码元所占的时间界限就会变得模糊，失去了码元之间的清晰界限。</p>
</blockquote>
<p>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决&#x2F;识别成为不可能。</p>
<p>如果信道的频带越宽，能通过的高频分量越多，就可以用更高的速率传送码元而不出现码间干扰。</p>
</li>
<li><p>信噪比<br>噪声存在于所有的电子设备和通信信道中，但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。</p>
<blockquote>
<p>信噪比: 信号的平均功率和噪声的平均功率之比，$S&#x2F;N$。单位为分贝(dB)。</p>
<p>$ 信噪比 &#x3D; 10 \log_{10}(S&#x2F;N)$</p>
</blockquote>
<blockquote>
<p>香农公式: 信道的极限信息传输速率$ C &#x3D; W \log_2(1 + S&#x2F;N) $</p>
<p>$ W $为信道的带宽，$ S $为信道内所传信号的平均功率，$ N $为信道内部的高斯噪声功率。</p>
</blockquote>
<p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</p>
<p>如果信道频带宽度一定，信噪比无法提升，码元的传输速率也达到了上限值，那么为了提高信息的传输速率，就要使用编码的方法使得每一个码元携带更多比特的信息量。</p>
</li>
</ol>
<h2 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h2><p>传输媒体也称传输介质&#x2F;传输媒介，是数据传输系统中在发送器和接收器之间的物理通路。</p>
<p>传输媒体可分为<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p>
<ol>
<li><p>双绞线&#x2F;双扭线</p>
<p>把两根互相绝缘的铜导线并排放在一起，然后用规则的方法<strong>绞合</strong>(twist)起来就构成了双绞线。</p>
<p>绞合可以减少对相邻导线的电磁干扰。</p>
<p>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。距离太长就需要放大器将衰减的信号放大到合适的数值(模拟传输)，中继器对失真的数字信号进行整形(数字传输)。</p>
<p><img src="/../images/network/twist_pair.png" alt="双绞线的示意图"></p>
<p>为了提高双绞线抗电磁干扰的能力，可以在双绞线的外面加上一层用金属丝编织成的屏蔽层，即<strong>屏蔽双绞线</strong>(STP，Shielded Twisted Pair)。以此作为区别，还有<strong>无屏蔽双绞线</strong>(UTP，Unshielded Twisted Pair)。</p>
<p>用于室内传送数据的无屏蔽双绞线和屏蔽双绞线的最新布线标准为EIA&#x2F;TIA-568-A。此标准规定了5个种类的UTP标准(1-5类线)。</p>
<p>5类线和3类线的最主要区别就是大大增加了每单位长度的绞合次数。3类线的绞合长度是7.5至10cm，5类线的绞合长度是0.6至0.85cm。</p>
<p><img src="/../images/network/UTP.png" alt="常用的绞合线的类别，带宽和典型应用"></p>
<p>无论是哪种类别的双绞线，衰减都随频率的升高而增大。使用更粗的导线可以降低衰减，增加导线的重量和价格。</p>
<p>信号应当有足够大的振幅，以便在噪声干扰下能够在接收端正确的被检测出来。</p>
<p>双绞线的最高速率还与数字信号的编码方法有关。</p>
</li>
<li><p>同轴电缆</p>
<p><img src="/../images/network/CoaxialCable.png" alt="同轴电缆的结构"></p>
<p>同轴电缆由内导体铜制芯线(单股实心线或多股绞合线)，绝缘层，网状编织的外导体屏蔽层以及保护塑料外层组成。</p>
<p>由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p>
<p>同轴电缆目前主用于在有限电视网的居民小区中。同轴电缆的带宽取决于电缆的质量。目前高质量的同轴电缆的带宽已接近1GHz。</p>
</li>
<li><p>光缆</p>
<p>光线通信就是利用光导纤维传递光脉冲来进行通信。光纤是光纤通信的传输媒体。</p>
<p>有光脉冲相当于1，没有光脉冲相当于0。</p>
<p>在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p>
<p>光纤通常由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体。纤芯很细，直径只有8~100微米。</p>
<p>光波通过纤芯进行传导。包层较纤芯有较低的折射率。当光线从该折射率的媒体射向低折射率媒体时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时就会折射回纤芯。这个过程不断重复，光也就会沿着光纤传输下去。</p>
<p>只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射。因此，可以存在多条不同角度入射的光线在一条光线中传输。这样的光纤叫做<strong>多模光纤</strong>。</p>
<p>多模光纤中，光脉冲在多模光纤中传输时会逐渐展宽，造成失真，只适合近距离传输。单模光纤是光纤的直径减少到只有一个光的波长，使光纤一直向前传播，不会产生多次反射。</p>
<p>光纤通信中常用的三个波段中心是850纳米，1300纳米和1550纳米。带宽为25000~30000GHz。</p>
<p>一根光缆少则只有一根光纤，多则可包括数十、数百根光纤，再加上加强芯和填充物可提高机械强度，可再加上远供电源线，最后加上包带层和外护套。这样就达到工程施工的强度要求。</p>
<p>光纤的特点：</p>
<ol>
<li>通信容量大</li>
<li>传输损耗小，中继距离长，对远距离传输很经济。</li>
<li>抗雷电和电磁干扰性能好。</li>
<li>无串音干扰，保密性好，也不易被窃听或截取数据。</li>
<li>体积小，重量轻。</li>
</ol>
</li>
</ol>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p>非导引型传输媒体，即自由空间。在非导引型传输媒体中电磁波的传输常称为无线传输。</p>
<p><img src="/../images/network/frequency_spectrum.png" alt="电信领域使用的电磁波的频谱"></p>
<p>   波段的正式名称：</p>
<ol>
<li><p>LF&#x2F;低频：波长1km~10km&#x2F;30kHz~300kHz。</p>
</li>
<li><p>MF&#x2F;中频：300kHz~3MHz。</p>
</li>
<li><p>HF&#x2F;高频：3MHz~30MHz。</p>
</li>
<li><p>VHF&#x2F;甚高频：30MHz~300MHz。</p>
</li>
<li><p>UHF&#x2F;特高频：300MHz~3GHz。</p>
</li>
<li><p>SHF&#x2F;超高频：3GHz~30GHz。</p>
</li>
<li><p>EHF&#x2F;极高频：30GHz~300GHz。</p>
</li>
<li><p>短波通信</p>
<blockquote>
<p>多径效应：同一个信号经过不同的反射路径到达同一个接收点，但各反射路径的衰减和时延都不相同，时的最后得到的合成信号失真很大。</p>
</blockquote>
<p>短波通信&#x2F;高频通信，主要靠电离层反射。但电离层的不稳定所产生的衰落现象以及电离层反射产生的多径效应，使得短波信道的通信质量较差。当必须使用短波无线电台传送数据时，一般是低速传输。</p>
</li>
<li><p>地面微波接力通信</p>
<p>地面微波接力通信和卫星通信同属无线电微波通信。</p>
<p>微波在空间中主要以直线传播。能够穿透电离层进入宇宙。</p>
<p>微波在空间中直线传播，地球是球体，传播距离受到限制，一般为50km。若采用100m高的天线塔，可增大到100km。</p>
<p>为实现远距离通信，在一条微波通信信道的两个终端之间建立若干个中继站。中继站把前一站传送过来的信号经过放大再发送到下一站。</p>
<p>微波接力通信可传输电话，电报，图像，数据等信息。主要特点是：</p>
<ol>
<li>微波波段频率很高，其频段范围很宽，其通信新到的容量很大。</li>
<li>微波通信因为其高频率，可以避免工业干扰和天气干扰，传输质量较高。</li>
<li>与相同容量和长度的电缆载波通信比较，微波接力通信建设性价比高。</li>
</ol>
<p>微波接力通信的缺点：</p>
<ol>
<li>相邻站之间必须直视，不能有障碍物。</li>
<li>微波的传输有时也会受到恶略天气的影响。</li>
<li>与电缆通信系统比较，微波通信的隐蔽性和保密性较差。</li>
<li>对大量中继站的使用和维护要耗费较多的人力和物力。</li>
</ol>
</li>
<li><p>卫星通信</p>
<p>常用的卫星通信方法是在地球站之间利用位于约3万6千公里高空的人造同步地球卫星作为中继器的一种微波接力通信。</p>
<p>卫星通信的最大特点是通信距离远，且通信费用与通信距离无关。</p>
<p>与微波接力通信相似，卫星通信的频带很宽，通信容量很大，信号受到的干扰也比较小，通信比较稳定。</p>
<p>卫星通信的另一特点是具有较大的传播时延。</p>
<p>在偏远地区进行通信几乎要完全依赖卫星通信。</p>
<p>上述卫星通信使用的是对地静止的卫星。现在低轨道卫星通信系统也开始使用。低轨道卫星不停绕地球旋转。目前，大功率，大容量，低轨道宽带卫星已经开始在空间部署，并构成了空间高速链路。</p>
</li>
</ol>
<p>另外，红外通信，激光通信也使用非引导型传输媒体，用于近距离的笔记本电脑相互传送数据。</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><strong>复用</strong>(multiplexing)最基本的是<strong>频分复用FDM</strong>(Frequency Division Multiplexing)和<strong>时分复用TDM</strong>(Time Division Multiplexing)。</p>
<p>在进行通信时，<strong>复用器</strong>(multiplexer)总是和<strong>分用器</strong>(demultiplexer)成对的使用。在复用器和分用器之间是用户共享的高速信道。</p>
<p>在发送端使用复用器，可以让复数用户共享一个信道。分用器把高速信道传送过来的数据进行分用，分别交付给相应的用户。</p>
<h3 id="频分复用和时分复用"><a href="#频分复用和时分复用" class="headerlink" title="频分复用和时分复用"></a>频分复用和时分复用</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(频带)资源。</p>
<p>把时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。时分复用的所有用户是在不同的时间占用相同的频带宽度。</p>
<p>上述两种复用方法的优点是技术比较成熟，但缺点是不够灵活。同时，时分复用更有利于数字传输。</p>
<h3 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h3><p>统计时分复用STDM(Statistic TDM)是一种改进的时分复用，能够提高信道利用率。</p>
<p><strong>集中器</strong>(concentrator)常用于统计时分复用。</p>
<p><img src="/../images/network/statistic_tdm.png" alt="统计时分复用的工作原理"></p>
<p>统计时分复用使用STDM帧来传送复用的数据，但每一个STDM帧中的时隙数小于连接在集中器上的用户数。</p>
<p>各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中。对没有数据的缓存就跳过去。当一个帧的数据放满了，就发送出去。因此，STDM帧不是固定分配时隙，而是按需动态分配时隙。因此，统计时分复用可以提高线路的利用率。</p>
<p>因为STDM帧中的时隙并不是固定的分配给每个用户，因此在每个时隙中还必须有用户的地址信息，这是统计时分复用必须要有的和不可避免的开销。</p>
<p>集中器又称智能复用器。它能提供对整个报文的存储转发能力，通过排队方式使各用户更合理地共享信道。</p>
<h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p><strong>波分复用WDM</strong>(Wavelength Division Multiplexing)就是光的频分复用。使用一根光纤同时传输多个频率很接近的光载波信号。</p>
<p>最初的波分复用，一根光纤只能复用两路光载波信号。<strong>密集波分复用</strong>(Dense Wavelength Division Multiplexing)可在一根光纤上复用几十路或更多路的信号。</p>
<p><img src="/../images/network/wavelength.png" alt="波分复用的概念"></p>
<p>首先将光载波调制到不同的波长。</p>
<p>送到光复用器&#x2F;合波器后，在一根光纤中传输。</p>
<p>光信号会在传输一段距离后衰减，因此需要对衰减了的光信号进行放大才能继续传输。现在利用<strong>掺铒光纤放大器</strong>(Erbium Doped Fiber Amplifier)，其不需要进行光电转换而直接对光信号进行放大。两个光纤放大器之间的光缆线路长度可达120km。</p>
<p>光复用器&#x2F;合波器和光分用器&#x2F;分波器之间的无光电转换的距离可达600k(4个EDFA光纤放大器)。</p>
<h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p><strong>码分复用CDM</strong>(Code Division Multiplexing)也是共享信道的方法。又称<strong>码分多址CDMA</strong>(Code Division Multiple Access)。</p>
<p>每一个用户可以在同样的时间使用同样的频带进行通信。这是因为各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。有很强的抗干扰能力，其频谱类似白噪声，不易被敌人发现。</p>
<p>CDMA可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率等。</p>
<blockquote>
<p><strong>码片</strong>(chip)指在CDMA中每一个比特再划分为<em>m</em>个短的间隔。 </p>
<p>通常<em>m</em>的值是64或者128。</p>
</blockquote>
<blockquote>
<p>扩频: 要发送信息的数据率为<em>b</em> bit&#x2F;s，由于每一个比特要转换成<em>m</em>个比特的码片，因此实际的发送数据率为<em>mb</em> bit&#x2F;s，其所占的频带也提高到原来数值的<em>m</em>倍。</p>
</blockquote>
<p>扩频通常有<strong>直接序列扩频DSSS</strong>(Direct Sequence Spread Spectrum)和<strong>跳频扩频FHSS</strong>(Frequency Hopping Spread Spectrum)。</p>
<ol>
<li><p>直接序列扩频<br><img src="/../images/network/DSSS.png" alt="直接序列扩频的工作原理"></p>
<p>使用码分多址的每一站被指派一个唯一的<em>m</em> bit<strong>码片序列</strong>(chip sequence)。</p>
<p>一个站如果要发送比特1，则发送它的<em>m</em> bit码片序列，如果要发送比特0，则发送该码片序列的反码。</p>
<p>在实用的系统中使用伪随机码序列，并且需要给每一个站分配的码片序列不相同的同时正交。</p>
<p>如果需要接收某站发送的数据，使用此站的唯一性码片序列和接受的数据流作内积，得到真实信号。</p>
</li>
<li><p>跳频扩频</p>
<p><img src="/../images/network/FHSS.jpg" alt="跳频扩频的工作原理"></p>
<p>使用码分多址的每一站被指派一个唯一的<em>m</em> bit<strong>码片序列</strong>(chip sequence)。</p>
<p>跳频是载波频率在一定范围内不断跳变意义上的扩频，而不是对被传送信息进行扩谱，不会得到直序扩频的处理增益。</p>
<p>解扩需要知道扩频码。</p>
</li>
</ol>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>从宽带接入的媒体来看，可以划分为有线宽带接入技术和无线宽带接入技术。现仅对有线宽带接入进行讨论。</p>
<h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><p><strong>非对称数字用户线ADSL</strong>(Asymmetric Digital Subscriber Line)技术是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务。</p>
<p>ADSL技术把0-4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<p>ADSL技术的传输距离取决于数据率和用户线的线径。用户线越细，信号传输时的衰减就越大。</p>
<p>ADSL在用户线的两端各安装一个ADSL调制解调器。我国目前采用的调制解调方案是<strong>离散多音调DMT</strong>(Discrete Multi-Tone)。</p>
<p>DMT调制技术采用频分复用的方法，把40kHz以上至1.1MHz的高端频谱划分为许多子信道，其中25个子信道用于上行信道，249个子信道用于下行信道，并使用不同的载波进行数字调制。</p>
<p>ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。当ADSL启动时，用户线两端的ADSL调制解调器就会测试可用的频率，各子信道受到干扰的情况以及在每一个频率上测试信号的传输质量。这样使得ADSL能够选择合适的调制方案以获得尽可能高的数据率。ADSL不能保证固定的数据率。</p>
<p>基于ADSL的接入网由以下三个部分组成：</p>
<p><img src="/../images/network/ADSL.png" alt="基于ADSL的接入网的组成"></p>
<ol>
<li><strong>数字用户线接入复用器DSLAM</strong>(DSL Access Multiplexer)。</li>
<li>用户线。</li>
<li>用户家的一些设施。</li>
</ol>
<p>   数字用户线接入复用器包括许多ADSL调制解调器。</p>
<p>   ADSL调制解调器又称<strong>接入端接单元ATU</strong>(Access Termination Unit)。</p>
<p>   由于ADSL调制解调器必须成对使用，因此把在电话端局&#x2F;远端站和用户家中所用的ADSL调制解调器分别记为ATU-C(entral Office)和ATU-R(emote)。</p>
<p>   用户电话通过电话<strong>分离器</strong>(Splitter)和ATU-R连在一起，经用户线到端局，并再次经过一个电话分离器把电话连到本地电话交换机。</p>
<p>   一个DSLAM可支持500~1000个用户。</p>
<p>ADSL可以利用现有电话网中的用户线，不需要重新布线。</p>
<p><img src="/../images/network/ATU.png" alt="ATU-R以及电话分离器"></p>
<p>ADSL调制解调器有两个插口，较大的一个是RJ-45，较小的一个是RJ-11。RJ-45用来与计算机相连，RJ-11用来与电话分离机相连。</p>
<p>电话分离机只需要用三个带有RJ-11插的连线就可以连接好。</p>
<p>ADSL借用了在用户线两端安装的ADSL调制解调器对数字信号进行调制，使得调制后的数字信号的频谱适合在原来的用户线上传输。</p>
<p>ADSL技术也在不断改进，ADSL2(G.992.3 G.992.4)和ADSL2+(G.992.5)是新提出的更高速率的第二代ADSL标准。</p>
<p>第二代ADSL的主要改进点在于：</p>
<ol>
<li>通过提高调制效率得到了更高的数据率。</li>
<li>采用了<strong>无缝速率自适应技术SRA</strong>(Seamless Rate Adaptation)。可在运营中不中断通信和不产生误码的情况下根据线路的实时状况，自适应的调整数据率。</li>
<li>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。</li>
</ol>
<p>ADSL适用于居民用户，这是因为居民上行数据并不多。但是ADSL技术并不适用于企业。企业需要使用上行信道发送大量数据给用户。为了满足企业的需求，ADSL技术有几种变形。</p>
<ol>
<li>对称DSL：把ADSL的带宽平均分配到上行和下行两个方向。</li>
<li>HDSL(High speed DSL): 使用一对线或两对线的对称DSL，用来取代T1线路的<strong>高速数字用户线</strong>。</li>
<li>VDSL(Very high speed DSL)，是ADSL的快速版本，又称甚高速数字用户线。</li>
</ol>
<h3 id="光纤同轴混合网-x2F-HFC网"><a href="#光纤同轴混合网-x2F-HFC网" class="headerlink" title="光纤同轴混合网&#x2F;HFC网"></a>光纤同轴混合网&#x2F;HFC网</h3><p><strong>光纤同轴混合网</strong>(HFC网, Hybrid Fiber Coax)是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话，数据和其他宽带交互型业务。</p>
<p>最早的有线电视网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向广播传输，改造后，成为光纤同轴混合网。</p>
<p>光纤同轴混合网的主要特点：</p>
<p><img src="/../images/network/HFC.png" alt="HFC网的结构图"></p>
<p>为了提高传输的可靠性和电视信号的质量，同轴电缆主干换为光纤，光纤从头端连接到<strong>光纤节点</strong>(fiber node)。在光纤节点光信号被转换为电信号，然后通过同轴电缆传送到每个用户家庭。</p>
<p>从头端到用户家庭所需的放大器因为末端采用同轴电缆数目仅有4~5个。</p>
<p>连接到一个光纤节点的典型用户数是500~2000。</p>
<p>光纤节点与头端的典型距离为25km，从光纤节点到其用户的距离则不超过2~3km。</p>
<p>原有有限电视网的最高传输频率是450MHz，并且仅用于电视信号的下行传输。光纤同轴混合网具有双向传输功能，而且扩展了传输频带。</p>
<p><img src="/../images/network/HFC_freq.png" alt="我国HFC的频带划分"></p>
<p>要使现有的模拟电视机能够接收数字电视信号，需要把<strong>机顶盒</strong>(set-top box)设备连接在同轴电缆和用户的电视机之间。同时，为了用户使用HFC网接入互联网，以及在上行信道中传送交互数字电视所需的一些信息，需要增加一个为HFC网使用调制解调器：<strong>电缆调制解调器</strong>(cable modem)。电缆调制解调器可以做成一个单独的设备，例如ADSL的猫，也可以做成内置式，安装在电视机的机顶盒中。</p>
<p>电缆调制解调器不需要成对使用，只需要安装在用户端。电缆调制解调器因为是多用户共享的，需要思考共享信道中可能出现的冲突问题。</p>
<h3 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h3><p>为了更快地下载视频文件，以及更加流畅的欣赏网上的各种高清视频节目，需要升级用户的上网效率，<strong>光纤到户FTTH</strong>(Fiber To The Home)从技术上来说是最好的选择。</p>
<p>光纤到户是把光纤一直铺设到用户家庭。只有到用户家庭后，才从光信号转化为电信号，使用户获得最高的上网效率。</p>
<p>问题:</p>
<ol>
<li>价格不够低。</li>
<li>用户需求不需要如此高的数据率。</li>
</ol>
<p>基于以上两个问题，出现了多种宽带光纤接入方式：FTTx。x表示不同的光纤接入地点。</p>
<p>为了有限利用光纤资源(问题2)，在光纤干线和广大用户之间还需要铺设一段中间的转换装置：<strong>光配线网ODN</strong>(Optical Distribution Network)，使得数十个家庭用户能够共享一根光纤干线。</p>
<p>无源光网络表明在光配网中无需配备电源，因此基本不要维护，长期运营和管理成本很低，而无源的光配网又称为<strong>无源光网络PON</strong>(Passive Optical Network)。</p>
<p><img src="/../images/network/ODN.png" alt="无源光配线网的组成"></p>
<p><strong>OLT光线路终端</strong>(Optical Line Terminal)是连接到光纤干线的终端设备。</p>
<p>OLT把收到的下行数据发往无源的1：N<strong>光分路器</strong>(splitter)，然后用广播向所有用户端的<strong>光网络单元ONU</strong>(Optical Network Unit)发送。典型的光分路器使用分路比是1：32，有时也可使用多级的光分路器。每个ONU根据特有的标识只接收发送给自己的数据，然后转换为电信号发往用户家中。每一个ONU到用户家的距离具体情况具体分析，OLT给ONU分配适当的光功率。</p>
<p>OLT发送上行数据时， 先把电信号转化为光信号，光分路器把各ONU发来的上行数据汇总后，以TDMA方式发往OLT，发送时间和长度由OLT集中控制，以便有序地共享光纤主干。</p>
<p>光配线网采用波分复用，上行和下行分别使用不同的波长。</p>
<p>FTTx有光纤到户FTTH，光纤到路边FTTC(urb)，光纤到小区FTTZ(one)，光线到大楼FTTB(uliding)，光纤到楼层FTTF(loor)，光纤到办公室FTTO(ffice)，光纤到桌面FTTD(esk)。</p>
]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 160. 相交链表</title>
    <url>/leetcode/160.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">headA, headB</span>):</span><br><span class="line">    a, countA, b, countB = headA, <span class="number">0</span>, headB, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        countA += <span class="number">1</span></span><br><span class="line">        a = a.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        countB += <span class="number">1</span></span><br><span class="line">        b = b.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># print(countA, countB)</span></span><br><span class="line">    <span class="keyword">if</span> countA &gt; countB:</span><br><span class="line">        c, cur, other = countA - countB, headA, headB</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c, cur, other = countB - countA, headB, headA</span><br><span class="line">    <span class="keyword">while</span> c &gt; <span class="number">0</span>:</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        c -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur != other:</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        other = other.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 155. 最小栈</title>
    <url>/leetcode/155.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = collections.deque()</span><br><span class="line">        self.min_stack = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> self.min_stack[-<span class="number">1</span>] &gt;= val:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> cur == self.min_stack[-<span class="number">1</span>]: self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/leetcode/152.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="/../images/leetcode/leetcode152.png" alt="解题思路"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ret, ma, mi = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            ma, mi = <span class="built_in">max</span>(mi * num, num), <span class="built_in">min</span>(ma * num, num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ma, mi = <span class="built_in">max</span>(ma * num, num), <span class="built_in">min</span>(mi * num, num)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, ma)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>软件测试笔记 1</title>
    <url>/books/soft_test1.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><strong>软件测试</strong>是通过考虑软件的<font color=blue>可靠性，可伸缩性，可移植性，可重用性，可用性</font>和评估软件组件的执行来查找软件错误或缺陷来识别软件正确性的过程。</p>
</blockquote>
<p>软件测试提供了软件的独立视图和目标，并确保软件的适用性。它涉及在所需服务下测试所有组件，以确认它是否满足指定的要求。该过程还向客户提供有关软件质量的信息。</p>
<blockquote>
<p><strong>测试</strong>是一组用于预定义脚本下确定应用程序正确性的技术。</p>
</blockquote>
<p>测试无法找到应用程序的所有缺陷，其主要目的是检测应用程序的故障，以便发现和纠正故障。其无法证明产品可以在所有条件下都能正常运行，仅表明它在某些特定条件下无法正常工作。</p>
<p>测试提供了比较软件的行为和状态与机制的比较，可以包括相同指定产品的过去版本，可比较产品，以及预期目的，相关标准或其他标准的界面等。</p>
<p>测试包括检查代码以及各种环境中的代码执行，条件以及代码的所有检查方面。</p>
<h1 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h1><blockquote>
<p>软件开发生命周期是一个创建软件开发结构的过程。</p>
<p>需求 → 设计 → 开发 → 测试</p>
</blockquote>
<ol>
<li><p>需求阶段</p>
<p>这是软件开发生命周期中最关键的阶段。</p>
<p>在此阶段，客户说明要求，规格，期望以及产品或者软件相关的任何其他特殊要求。</p>
</li>
<li><p>设计阶段</p>
<p>这是软件开发生命周期中的高优先阶段。</p>
<p>设计阶段包括根据需求阶段对新软件的详细分析，系统的逻辑设计转换为物理设计。</p>
<p>需求阶段的输出是所需事物的集合，设计阶段为实现这些需求提供了方法。</p>
</li>
<li><p>建设&#x2F;设计阶段</p>
<p>这是软件开发周期中花费最长的时间，使用最集中的方法的阶段。</p>
<p>在成功完成需求和设计阶段后，下一步是将设计实现到软件系统的开发中。</p>
<p>编码由开发团队根据前一个阶段讨论的设计开始，并根据需求阶段讨论的客户要求产生的所需的结果。</p>
<p>前端开发人员开发简单的且具有吸引力的GUI和必要的接口，以便与后端操作进行交互，后端开发人员根据所需的操作进行后端编码。</p>
</li>
<li><p>测试阶段</p>
<p>测试阶段是完成软件系统的最后一步。</p>
<p>在获得开发的的GUI和后端组合之后，将根据需求阶段中的要求对其进行测试。测试确定软件是否实际按照需求阶段中的要求提供结果。</p>
<p>测试计划包括所有类型的测试。如果软件中存在任何缺陷，或者它没有按照预期工作，那么测试团队会向开发团队提供有关该问题的详细信息。</p>
</li>
<li><p>部署&#x2F;交付阶段</p>
<p>当软件测试完成，且结果令人满意，并且软件工作中没有余留问题时，就可以进行交付，供客户使用。</p>
<p>当客户收到产品，首先进行beta测试。在beta测试中，客户可以要求软件中没有但在需求文档或任何其他GUI更改中提及的任何更改，以使其更加用户友好。</p>
</li>
<li><p>维护阶段</p>
<p>维护是软件开发生命周期的最后和持久阶段。</p>
<p>当客户开始使用软件时，实际问题就开始发生，那时需要解决这些问题。同时，还包括对硬件和软件进行更改以维持其运营效率。</p>
</li>
</ol>
<h1 id="软件测试生命周期"><a href="#软件测试生命周期" class="headerlink" title="软件测试生命周期"></a>软件测试生命周期</h1><ol>
<li><p>需求分析</p>
<p>手动测试程序的第一步是需求分析。测试人员分析需求文档，检查客户所述的要求。在检查要求后，测试人员制定测试计划以检查软件是否满足要求。</p>
<p>应当提供应用程序体系结构文档和明确定义的验收标准。</p>
<p>准备所有要求和查询的列表，列出要执行的所有类型的测试，列出测试环境详细信息。</p>
<p>此阶段的交付成果是列出可测试要求和测试环境详细信息的所有必要测试。</p>
</li>
<li><p>测试计划</p>
<p>创建测试计划是软件测试生命周期的关键阶段，定义了所有测试策略。</p>
<p>测试人员确定整个项目的估计工作量和成本。</p>
<p>列出测试中涉及的方法，测试过程概述。</p>
<p>解决测试环境，准备测试计划和控制程序，确定角色和责任，列出测试可交付成果，定义风险。</p>
<p>此阶段的交付成果是测试估算文件。</p>
</li>
<li><p>环境设置</p>
<p>测试环境是一项独立的活动，可以和测试用例开发一起进行。</p>
<p>环境设置需要一组必要的软件和硬件来创造测试环境。</p>
<p>通过分析需求规范来准备软件和硬件列表。在设置测试环境后，执行测试用例以检查测试环境的准备情况。</p>
</li>
<li><p>测试用例</p>
<p>测试团队启动案例开发和执行。测试团队记下详细的测试用例，并在需要时准备测试数据。</p>
<p>此阶段的交付成果是测试执行结果以及具有缺陷详细说明的功能列表。</p>
</li>
<li><p>缺陷记录</p>
<p>测试人员和开发人员根据测试覆盖范围，质量，时间消耗，成本和关键业务目标评估软件的完成标准。此阶段确定了软件的特性和缺点。</p>
<p>深入分析测试用例和错误报告，以检测缺陷的类型及其严重性、</p>
<p>缺陷记录分析主要用于根据严重程度和类型找出缺陷分布。</p>
<p>此阶段的完成标志测试的结束，交付关闭报告和测试指标。</p>
</li>
<li><p>测试周期</p>
<p>关闭测试周期结束报告包括与软件设计，开发，测试结果和缺陷报告相关的所有文档。如果存在具有相同规范的软件，此阶段将评估开发策略，测试过程，可能的缺陷，以便将来使用这些实践。</p>
<p>此阶段交付测试结束报告。</p>
</li>
</ol>
<h1 id="软件质量保证-QA-和软件质量控制-QC"><a href="#软件质量保证-QA-和软件质量控制-QC" class="headerlink" title="软件质量保证(QA)和软件质量控制(QC)"></a>软件质量保证(QA)和软件质量控制(QC)</h1><h2 id="软件质量保证-QA"><a href="#软件质量保证-QA" class="headerlink" title="软件质量保证(QA)"></a>软件质量保证(QA)</h2><p>   软件质量保证用于防止缺陷并确保为特定应用程序设计的技术，方法，和过程必须正确实施。</p>
<p>   质量保证测试确保了高质量软件的开发，因为它主要关注软件开发过程中的高质量流程，良好的质量管理体系和定期的一致性审核。</p>
<p>   软件质量保证是一种管理工具，包括计划和系统的活动文件，以防止与质量有关的问题。</p>
<p>   软件质量保证的责任是每一个开发团队成员的责任。</p>
<h2 id="软件质量控制-QC"><a href="#软件质量控制-QC" class="headerlink" title="软件质量控制(QC)"></a>软件质量控制(QC)</h2><p>   软件质量控制也称为质量控制，是一系列任务，也是一个被动的过程，主要目的在于在发布软件之前纠正所有类型的缺陷。</p>
<p>   通过识别缺陷和纠正开发软件中的缺陷来确保软件质量。</p>
<p>   通过纠正工具消除问题根源，从而使软件能够满足用户的要求和高质量，从而完成该过程。</p>
<p>   质量控制的责任在于测试团队，通过验证和纠正工具测试软件的缺陷。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">质量保证QA</th>
<th align="center">质量控制QC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="center">质量保证是一组活动，可确保始终保持软件开发过程中使用的过程质量。</td>
<td align="center">QC是一组用于检测已开发软件中的缺陷的活动。</td>
</tr>
<tr>
<td align="center">关注重点</td>
<td align="center">通过关注流程来防止开发软件中的缺陷。</td>
<td align="center">通过关注测试过程来识别开发软件中缺陷。</td>
</tr>
<tr>
<td align="center">如何做</td>
<td align="center">建立高质量的管理系统，并定期审核开发软件的操作是否符合要求。</td>
<td align="center">通过使用开发软件中的测试技术和工具来检测和消除质量问题。</td>
</tr>
<tr>
<td align="center">为什么做</td>
<td align="center">通过使用包括文档在内的系统活动来确保质量问题。</td>
<td align="center">通过使用流程和技术来实现和维护高质量的软件，从而确保识别和消除缺陷。</td>
</tr>
<tr>
<td align="center">面向</td>
<td align="center">流程</td>
<td align="center">产品</td>
</tr>
<tr>
<td align="center">过程类型</td>
<td align="center">积极主动</td>
<td align="center">QC是一种反应过程，因为它涉及在产品开发之后和产品发布之前识别缺陷。</td>
</tr>
<tr>
<td align="center">责任</td>
<td align="center">开发团队每个成员</td>
<td align="center">特定的检测团队</td>
</tr>
<tr>
<td align="center">示例</td>
<td align="center">验证软件流程</td>
<td align="center">检验软件功能和流程</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>校招</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 148. 排序链表</title>
    <url>/leetcode/148.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        slow, fast = slow.<span class="built_in">next</span>, fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    mid, slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">    left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line"></span><br><span class="line">    res = h = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">            h.<span class="built_in">next</span> = left</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            h.<span class="built_in">next</span> = right</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        h = h.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left: h.<span class="built_in">next</span> = left</span><br><span class="line">    <span class="keyword">elif</span> right: h.<span class="built_in">next</span> = right</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记 1</title>
    <url>/books/network_1.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="21世纪的计算机网络"><a href="#21世纪的计算机网络" class="headerlink" title="21世纪的计算机网络"></a>21世纪的计算机网络</h2><p>21世纪特征: 数字化，网络化， 信息化，是一个以网络为核心的时代。</p>
<p>网络包括: 电信网络，有线电视网络，计算机网络。</p>
<ol>
<li>电信网络: 提供电话，电报及传真服务；</li>
<li>有线电视网络: 传送各种电视节目；</li>
<li>计算机网络: 在计算机之间传送数据文件。</li>
</ol>
<p>互联网(Internet)的基本特点: 连通性， 共享。</p>
<h2 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h2><p>计算机网络(网络)由若干节点(node)和连接这些节点的链路(link)组成。<strong>节点</strong>可以是计算机，集线器，交换机或路由器等。</p>
<blockquote>
<p>注: 习惯上，把与网络相连的计算机称为主机(host)。<br>注: internet泛指由多个计算机网络互连而成的计算机网络；Internet指当前全球最大的，开放的，由众多网络相互连接而成的特定互联网，它采用TCP&#x2F;IP协议族作为通信的规则，且其前身是美国的ARPANET。</p>
</blockquote>
<p>网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。</p>
<h3 id="ISP-Internet-Service-Provider"><a href="#ISP-Internet-Service-Provider" class="headerlink" title="ISP(Internet Service Provider)"></a>ISP(Internet Service Provider)</h3><p><strong>互联网服务提供者ISP</strong>可分为主干ISP，地区ISP，本地ISP。</p>
<p>主干ISP(移动，联通)服务面积最大(国家级别)，拥有高速主干网，一些地区ISP可直接与主干ISP相连。<br>地区ISP是一些较小的ISP，地区ISP一般通过一个或多个主干ISP连接起来。<br>本地ISP(企业，大学)给用户提供直接的服务。本地ISP可以连接到地区ISP，也可以直接连接到主干ISP。</p>
<p>理论上讲，只要每一个本地ISP都安装路由器连接到某个地区ISP，每一个地区ISP也有路由器连接到主干ISP，在这些相互连接的ISP共同合作下，就可以完成互联网中的所有分组转发任务。<br>但随着互联网上数据流量的急剧增长，需要研究更快的转发分组，以及更有效地利用网络资源，提出**互联网交换点IXP(Internet eXchange Point)**。</p>
<h3 id="互联网交换点IXP-Internet-eXchange-Point"><a href="#互联网交换点IXP-Internet-eXchange-Point" class="headerlink" title="互联网交换点IXP(Internet eXchange Point)"></a>互联网交换点IXP(Internet eXchange Point)</h3><p>互联网交换点IXP的主要作用是允许两个网络直接相连并交换分组，不需要通过第三个网络来转发分组。</p>
<p>若两个地区ISP通过一个IXP连接起来，主机之间进行交换分组时，不必经过主干ISP，直接在两个地区ISP之间用高速链路对等的交换分组。使得互联网上的流量数据分布更加合理，同时减少了分组转发的延迟时间，降低了分组转发的费用。</p>
<p>典型的IXP由一个或多个网络交换机组成，许多ISP再连接到这些网络交换机的相关端口上。IXP常采用工作在<strong>数据链路层</strong>的数据交换机，这些网络交换机都哟格局与网互联起来。</p>
<h3 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h3><p>互联网从工作方式看，可以划分为边缘部分及核心部分。</p>
<ol>
<li><p>边缘部分: 由所有连接在互联网上的主机组成。是用户直接使用的，用于通信和资源共享。</p>
</li>
<li><p>核心部分: 由大量网络和连接这网络的路由器组成。为边缘部分提供服务，提供连通性和交换。</p>
</li>
</ol>
<h4 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h4><p>   处于互联网边缘的部分，连接在互联网上的所有主机。又称为端系统(end system)。</p>
<p>   边缘部分利用核心部分提供的服务，使众多主机之间能够互相通信并交换或共享信息。</p>
<p>   更严格的说，主机A和主机B进行通信，应该表述为，运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信，即，主机A的某个进程和主机B上的另一个进程通信。</p>
<p>   在网络边缘的端系统之间的通信方式通常划分为客户-服务器方式(C&#x2F;S)和对等方式(P2P)。</p>
<ol>
<li><p>客户-服务器通信方式</p>
<p> <img src="/../images/network/C_S.png" alt="客户-服务器方式"></p>
<p> 这是互联网上最常用，传统的方式。</p>
<p> 客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。</p>
<p> 主机A运行客户程序，主机B运行服务器程序。客户是服务请求方，服务器是服务提供方。</p>
<p> 客户A向服务器B发出服务请求，服务器B向客户A提供服务。二者都要使用网络核心部分所提供的服务。</p>
<p> 客户程序:</p>
<p> a. 被用户调用后运行，在通信时主动向远地服务器发起通信(请求服务)。需要知道服务器程序的地址。</p>
<p> b. 不需要特殊的硬件和很复杂的操作系统。</p>
<p> 服务器程序: </p>
<p> a. 专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</p>
<p> b. 系统启动后即自动调用并一直不断的运行着，被动地等待并接受来自各地的客户的通信请求。不需要知道客户程序地址。</p>
<p> c. 需要强大的硬件和高级的操作系统支持。</p>
<p> 在客户和服务器的通信建立后，通信是双向的，二者都可以发送和接收数据。</p>
</li>
<li><p>对等连接方式</p>
<p><img src="/../images/network/p2p.png" alt="对等连接工作方式"></p>
<p>两台主机在通信时并不区分哪一个是服务请求方，哪一个是服务提供方。只要两台主机都运行了对等连接软件，就可以进行平等，对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。</p>
</li>
</ol>
<h4 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h4><p>   网络核心部分是互联网中最复杂的部分，因为网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一台主机都能够向其他主机通信。</p>
<p>   在网络核心部分起特殊作用的是<strong>路由器</strong>，它是一种专用计算机，是用于实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p>
<blockquote>
<p>电路交换<br>必须经过<strong>建立连接</strong>(占用通信资源)，<strong>通话</strong>(一直占用通信资源)，<strong>释放连接</strong>(归还通信资源)三个步骤的交换方式。</p>
</blockquote>
<p>   电路交换在通信过程一直占用通信资源，在用来传送计算机数据时，其线路的传输效率会很低。</p>
<ul>
<li>分组交换</li>
</ul>
<p>   分组交换采用<strong>存储转发</strong>技术。</p>
<p>   通常把一个报文(message)划分成几个分组(packet, 首部(header) + 比报文小的等长数据段)后再进行传送。</p>
<p>   分组是在互联网中传送的数据单元。分组(packet)，又称包；首部(header)，又称包头。首部包含了诸如目的地址和源地址等重要控制信息，确保分组在互联网中独立地选择传输路径，并被正确的交付到分组传输的终点。</p>
<blockquote>
<p>路由器的分组交换</p>
<p>路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表(路由器记录)，按照首部中的目标地址，找到合适的接口转发出去，把分组交给下一个路由器。</p>
<p>这样一步一步地以存储转发的方式，把分组交付给最终的目的主机。</p>
<p><font color=red> 各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。 </font></p>
</blockquote>
<p>   <img src="/../images/network/packet_eg.png" alt="分组转发示例"></p>
<p>   假定主机$H_1$向主机$H_5$发送数据。</p>
<p>   主机$H_1$先将分组逐个地发往与它直接相连的路由器$A$中。此时除链路$H_1 - A$外，其他通信链路并不被目前通信的双方所占用。<br>   即使是链路$H_1 - A$，也只是当分组正在此链路上传送时才被占用。在各分组传送之间的空闲时间，链路$H_1 - A$仍可为其他主机发送的分组使用。</p>
<p>   路由器A把主机$H_1$发来的分组放入缓存。假定从路由器$A$的转发表中查出应把该分组转发到链路$A - C$。于是把分组就转发到路由器$C$，再转发到路由器$E$，最终到主机$H_5$。<br>   若链路$A- C$的通信量太大，路由器$A$可以把分组沿另一个路由传送，即把分组转发到路由器$B$，再转发到路由器$E$，最终到主机$H_5$。</p>
<p>   分组转发在传送数据之前不必先占用一条端到端的链路的通信资源，同时省去了建立连接和释放连接的开销，因此数据的传输效率更高。</p>
<p>   采用存储转发的分组转发实际是采用了在数据通信的过程中断续&#x2F;动态分配传输带宽的策略。</p>
<p>   为了提高分组交换的可靠性，互联网的核心部分常采用网络拓扑结构，使得当发生网络堵塞或少数节点，链路出现故障时，路由器可以灵活地改变转发路由器而不致引起通信的中断或全网瘫痪。<br>   此外，通信网络的主干线路往往由一些高速链路构成，这样就可以较高的数据率迅速地传送计算机数据。</p>
<p>   分组交换的优点：</p>
<ol>
<li>高效: 在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。</li>
<li>灵活: 为每一个分组独立地选择最合适的转发路由。</li>
<li>迅速: 以分组为传送单位，可以不先建立链接就可以向其他主机发送分组。</li>
<li>可靠: 保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</li>
</ol>
<p>   电路交换: 整个报文的比特流连续的从源点直达终点，好像在一个管道中传送。</p>
<p>   报文交换: 整个报文先传送到相邻接点，全部存储下来后查找转发表，转发到下一个节点。</p>
<p>   分组交换: 单个交换传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</p>
<p>   <img src="/../images/network/differ.png" alt="电路交换 报文交换 分组交换的区别"></p>
<p>   若要连续传送大量的数据，且其传送时间远大于链接建立时间，则电路交换的传输速率较快。<br>   报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。<br>   由于一个分组的长度往往远小于整个报文的长度，因此分组交换币报文交换的时延小，同时具有更好的灵活性。</p>
<h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><p>   按照网络的作用范围进行分类:</p>
<ol>
<li>广域网WAN(Wide Area Network): 是互联网的核心部分，通过长距离(跨国)运送主机所发送的数据。连接广域网各节点交换机的链路一般是高速链路，具有较大的通信容量。</li>
<li>城域网MAN(Metropolitan Area Network): 可跨越几个街区乃至整个城市。用于将多个局域网进行互连。目前很多城域网采用的是以太网技术。</li>
<li>局域网LAN(Local Area Network): 一般用微型计算机或工作站通过高速通信线路相连，地理局限范围小。</li>
<li>个人区域网PAN(Personal Area Network): 在10m左右的范围把属于个人的电子设备用无线技术连接起来的网络。</li>
</ol>
<p>   按照网络的使用者进行分类:</p>
<ol>
<li>公用网(public network): 所有按照愿意按电信公司的规定缴纳费用的人都可以使用这种网络。</li>
<li>专用网(private network): 某个部门为了满足本单位的特殊业务工作的需要而建造的网络。不向本单位以外的人提供服务。</li>
</ol>
<h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><ol>
<li><p>速率</p>
<p>数据的传送速率，数据率(data rate)&#x2F;比特率(bit rate)。</p>
<p>一般提到网络的速率，指的是额定速率或标称速率，不是实际的网络运行速率。</p>
</li>
<li><p>带宽</p>
<p>在频域中，衡量模拟信号时，带宽指某个信号具有的频带宽度，单位为赫兹，表示某信道允许通过的信号频带范围。</p>
<p>在时域中，衡量数字信号时，带宽指在单位时间内网络中某信道所能通过的最高数据率，单位为比特每秒。表示网络中某通道传送数据的能力。</p>
</li>
<li><p>吞吐量(throughout)</p>
<p>表示在单位时间内通过某个网络&#x2F;信道&#x2F;接口的实际的数据量。</p>
<p>吞吐量是对实际网络数据量通过的衡量，受网络的带宽或网络的额定速率的限制。</p>
</li>
<li><p>各种时延</p>
<p>时延(delay&#x2F;latency)，又称延迟&#x2F;迟延，指数据从网络的一端传送到另一端所需的时间。</p>
<p><img src="/../images/network/time_delay.png" alt="各种时延"></p>
<p><strong>发送时延</strong>(transmission delay)，又称传输时延，是主机或路由器发送数据帧所需要的时间，即从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p>
<p>$$ 发送时延 &#x3D; \frac{数据帧长度(bit)}{发送速率(bit&#x2F;s)} $$</p>
<p>发送时延并非固定不变，而是与发送的帧长成正比，与发送速率成反比。</p>
<p><strong>传播时延</strong>(propagation delay)是电磁波在信道中传播一定的距离需要花费的时间。</p>
<p>$$ 传播时延 &#x3D; \frac{信道长度(m)}{电磁波在信道上的传播速率(m&#x2F;s)} $$</p>
<p>传播时延与信号的发送速率无关，信号传送的距离越远，传播时延越大。</p>
<p><strong>处理时延</strong>即主机或路由器在收到分组时需要花费一定的时间进行处理。</p>
<p><strong>排队时延</strong>即分组在经过网络传输时，要经过许多路由器。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发接口后，在输出队列中排队等待转发，产生排队时延。</p>
<p>$$ 总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延 $$</p>
</li>
<li><p>时延带宽积</p>
<p>$$ 时延带宽积 &#x3D; 传播时延 \times 带宽 $$</p>
<p>以比特为单位的链路长度。</p>
</li>
<li><p>往返时间RTT</p>
<p>RTT(Round-Trip Time)表示信息双向交互的时间。</p>
</li>
<li><p>利用率</p>
<p>分为信道利用率和网络利用率。</p>
<p>信道利用率指某信道有数据通过的时间；网络利用率指全网络的信道利用率的加权平均值。</p>
<p>信道利用率不是越大越好，根据公式</p>
<p>$$ D &#x3D; \frac{D_0}{1 - U} $$</p>
<p>信道或网络的利用率过高会产生非常大的时延。</p>
<p><img src="/../images/network/delay_use.png" alt="时延与利用率的关系"></p>
</li>
</ol>
<h3 id="计算机网络的非性能指标"><a href="#计算机网络的非性能指标" class="headerlink" title="计算机网络的非性能指标"></a>计算机网络的非性能指标</h3><ol>
<li><p>费用</p>
<p>一般，网络的速率越高，价格越高。</p>
</li>
<li><p>质量</p>
<p>网络的质量取决于网络中所有构件的质量，以及这些构建是怎样组成网络的。</p>
</li>
<li><p>标准化</p>
<p>网络的硬件和软件的设计即可以按照通用的国际标准，也可以遵循特定的专用网络标准。最好遵循国际标准，可以得到更好的互操作性，易于升级换代和维修，以及技术上的支持。</p>
</li>
<li><p>可靠性</p>
<p>可靠性与网络的质量和性能密切相关。</p>
</li>
<li><p>可扩展性和可升级性</p>
<p>网络的性能越高，其扩展费用往往也越高，难度也会相应增加。</p>
</li>
<li><p>易于管理和维护</p>
<p>网络如果没有良好的管理和维护，就很难达到和保持所设计的性能。</p>
</li>
</ol>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>   计算机网络的各层及其协议的集合就是网络的体系结构，即计算机网络机器狗和构建所应完成的功能。</p>
<p>   分层带来的优点:</p>
<ol>
<li>各层之间是独立的：层级之间只需要知道该层通过层间的接口所提供的服务。</li>
<li>灵活性好：只要层间接口关系保持不变，层内部的改变不影响这层以上或以下各层。</li>
<li>结构上可分隔开。</li>
<li>易于实现和维护。</li>
<li>促进标准化工作：<br>各层完成的功能可以是以下的任务的集合：<ol>
<li>差错控制：使相应层次对等方的通信更加可靠。</li>
<li>流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。</li>
<li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li>
<li>复用和分用 发送端几个高层会话复用一条底层的链接，在接收端再分用。</li>
<li>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放链接。</li>
</ol>
</li>
</ol>
<p>   网络协议用来实现在计算机网络中有条不紊的交换数据，明确规定了所交换数据的格式以及有关的同步问题。</p>
<p>   网络协议(network protocol)是为进行网络中的数据交换而建立的规则，标准或约定。</p>
<p>   网络协议包含三个要素：</p>
<ol>
<li>语法：数据与控制信息的结构或格式。</li>
<li>语义：需要发出何种控制信息，完成何种动作以及做出何种相应。</li>
<li>同步：时间实现顺序的详细说明。</li>
</ol>
<p>   <img src="/../images/network/OSI_TCPIP.png" alt="计算机网络体系结构"></p>
<p>   目前，计算机体系结构中，TCP&#x2F;IP的四层结构是常实现的结构，为了讲解清楚，采用OSI和TCP&#x2F;IP的优点，讲解5层体系结构。</p>
<ol>
<li><p>应用层(application layer)</p>
<p>应用层是体系结构中的最高层。</p>
<p>任务是通过应用进程之间的交互来完成特定网络应用。</p>
<p>应用层协议定义的是应用进程之间通信和交互的规则。互联网中的应用层协议有: 域名系统DNS，支持万维网应用的HTTP等。</p>
<p>应用层交互的数据单元称为报文。</p>
</li>
<li><p>运输层(transport layer)</p>
<p>运输层的任务是负责向两台主机中进程之间提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p>
<p>由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。</p>
<blockquote>
<p><strong>复用</strong>：多个应用层进程可同时使用下面的运输层服务。</p>
<p><strong>分用</strong>：运输层把收到的信息分别交付给上面应用层的相应进程。</p>
</blockquote>
<p>运输层主要使用TCP协议和UDP协议。</p>
<blockquote>
<p><strong>传输控制协议TCP</strong>(Transmission Control Protocol)：提供面向连接，可靠的的数据传输服务，其数据传输的单位是报文段(segment)。</p>
<p><strong>用户数据报协议UDP</strong>(User Datagram Protocol)：提供无连接，尽最大努力的数据传输服务。其数据传输的单位是用户数据报。</p>
</blockquote>
</li>
<li><p>网络层(network layer)</p>
<p>一个任务是为分组交换网上的不同主机提供通信服务，另一个任务是选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。</p>
<p>在发送数据时，网络层把运输层产生的报文段或用户数据包封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组&#x2F;包也叫IP数据报，或简称数据报。</p>
</li>
<li><p>数据链路层&#x2F;链路层(data link layer)</p>
<p>两台主机之间的数据传输，总是在一段一段的链路上传送的，因此需要使用专门的链路层协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报<strong>组装成帧</strong>(framing)，在两个相邻节点间的链路上传送<strong>帧</strong>(frame)。</p>
<p>每一帧包括数据和必要的控制信息。控制信息一是使得接收端在接收数据时能够知道一个帧从哪个比特开始和到那个比特结束，使得数据链路层在收到一个帧后从中提取数据部分上交给网络层。二是使得接收端能够检测到所收到的帧中是否有差错，若存在差错，数据链路层丢弃该帧，或者需要修正差错，需要使用可靠传输协议来纠错。</p>
</li>
<li><p>物理层(physical layer)</p>
<p>在物理层上所传送的数据的单位是比特。物理层需要考虑用多大的电压代表二进制位，以及接收方如何识别发送方所发送的比特，还需要确认连接电缆的插头应当有多少根引脚以及各引脚应如何连接。</p>
</li>
</ol>
<p>   <img src="/../images/network/data_in_network.png" alt="数据在各层之间的传递过程"></p>
<p>   假定两台主机通过一台路由器连接起来，主机1的应用进程$ AP_1 $向主机2的应用进程$ AP_2 $传送数据。说明应用进程的数据在各层之间传递过程中经历的变化。</p>
<ol>
<li>$ AP_1 $先将数据交给本主机的应用层。</li>
<li>应用层加上必要的控制信息$ H_5 $就变成了下一层的数据单元。</li>
<li>运输层收到这个数据单元后，加上本层的控制信息$ H_4 $就变成了下一层的数据单元。</li>
<li>网络层收到这个数据单元后，加上本层的控制信息$ H_3 $就变成了下一层的数据单元。</li>
<li>数据链路收到这个数据单元后，本层控制信息分为头部$ H_2 $和尾部$ T_2 $进行添加就变成了下一层的数据单元。</li>
<li>物理层收到这个数据单元后，以比特进行传送。</li>
<li>比特流离开主机1网络的物理媒体传送到路由器时，就从路由器的第一层依次上升到第三层，每一层都根据控制信息进行必要的操作，将控制信息剥去，该层剩下的数据单元上交给更高一层。</li>
<li>当分组上升到第3层时，根据首部中的目的地址查找路由器中的转发表，找出转发分组的接口，往下传送到第2层，加上新的首部和尾部控制信息后。再到最下面第1层，接着在物理媒体上把每一个比特发送出去。</li>
<li>比特流离开路由器到达目的站主机2时，就从主机2的的第1层依次上升到最高层第5层。</li>
<li>最后，应用进程$ AP_1 $发送的数据交给目的站的应用程序$ AP_2 $。</li>
</ol>
]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 146. LRU缓存</title>
    <url>/leetcode/146.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">关键在于时间戳的处理</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.cap = &#123;&#125;</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.tim = []</span><br><span class="line">        self.<span class="built_in">all</span> = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur = self.cap.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> cur != -<span class="number">1</span>:</span><br><span class="line">            self.tim.pop(self.tim.index(key))</span><br><span class="line">            self.tim.append(key)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cap.keys():</span><br><span class="line">            self.tim.pop(self.tim.index(key))</span><br><span class="line">            self.tim.append(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.count &lt; self.<span class="built_in">all</span>:</span><br><span class="line">                self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = self.tim.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">del</span> self.cap[cur]</span><br><span class="line">            </span><br><span class="line">            self.tim.append(key)</span><br><span class="line">        self.cap[key] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<h1 id="hash-双向链表-只有虚拟头结点"><a href="#hash-双向链表-只有虚拟头结点" class="headerlink" title="hash + 双向链表(只有虚拟头结点)"></a>hash + 双向链表(只有虚拟头结点)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">关键在于时间戳的处理, 官方建议用双向链表实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, val, nex=<span class="literal">None</span>, pre=<span class="literal">None</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = nex</span><br><span class="line">        self.pre = pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.lis = Node(-<span class="number">1</span>, -<span class="number">1</span>)   </span><br><span class="line">        self.values = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.values:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.values[key]</span><br><span class="line">        self.remove(node)</span><br><span class="line">        self.add_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.values:</span><br><span class="line">            node = Node(key, value)</span><br><span class="line">            self.add_head(node)</span><br><span class="line">            <span class="keyword">if</span> self.size == self.capacity:</span><br><span class="line">                del_key = self.remove_tail()</span><br><span class="line">                <span class="keyword">del</span> self.values[del_key]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.size += <span class="number">1</span></span><br><span class="line">            self.values[key] = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.values[key]</span><br><span class="line">            self.remove(node)</span><br><span class="line">            node.val = value</span><br><span class="line">            self.values[key] = node</span><br><span class="line">            self.add_head(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>: node.<span class="built_in">next</span>.pre = node.pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_head</span>(<span class="params">self, node</span>):</span><br><span class="line">        cur = self.lis.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            cur.pre.<span class="built_in">next</span> = node</span><br><span class="line">            node.<span class="built_in">next</span> = cur</span><br><span class="line">            node.pre = self.lis</span><br><span class="line">            cur.pre = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.lis.<span class="built_in">next</span> = node</span><br><span class="line">            node.pre = self.lis</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_tail</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.lis</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        self.remove(cur)</span><br><span class="line">        <span class="keyword">return</span> cur.key</span><br></pre></td></tr></table></figure>

<h1 id="hash-双向链表-存在虚拟头结点和虚拟尾节点"><a href="#hash-双向链表-存在虚拟头结点和虚拟尾节点" class="headerlink" title="hash + 双向链表(存在虚拟头结点和虚拟尾节点)"></a>hash + 双向链表(存在虚拟头结点和虚拟尾节点)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">关键在于时间戳的处理, 官方建议用双向链表实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, val, nex=<span class="literal">None</span>, pre=<span class="literal">None</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = nex</span><br><span class="line">        self.pre = pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.start = Node(-<span class="number">1</span>, -<span class="number">1</span>)   </span><br><span class="line">        self.end = Node(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        self.start.<span class="built_in">next</span> = self.end</span><br><span class="line">        self.end.pre = self.start</span><br><span class="line">        self.values = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.values:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.values[key]</span><br><span class="line">        self.remove(node)</span><br><span class="line">        self.add_tail(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.values:</span><br><span class="line">            node = Node(key, value)</span><br><span class="line">            self.add_tail(node)</span><br><span class="line">            <span class="keyword">if</span> self.size == self.capacity:</span><br><span class="line">                del_key = self.remove_head()</span><br><span class="line">                <span class="keyword">del</span> self.values[del_key]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.size += <span class="number">1</span></span><br><span class="line">            self.values[key] = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.values[key]</span><br><span class="line">            self.remove(node)</span><br><span class="line">            node.val = value</span><br><span class="line">            self.values[key] = node</span><br><span class="line">            self.add_tail(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.pre = node.pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_tail</span>(<span class="params">self, node</span>):</span><br><span class="line">        self.end.pre.<span class="built_in">next</span> = node</span><br><span class="line">        node.<span class="built_in">next</span> = self.end</span><br><span class="line">        node.pre = self.end.pre</span><br><span class="line">        self.end.pre = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_head</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.start.<span class="built_in">next</span></span><br><span class="line">        self.remove(cur)</span><br><span class="line">        <span class="keyword">return</span> cur.key</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 142. 环形链表II</title>
    <url>/leetcode/142.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p><img src="/../images/leetcode/leetcode142.jpeg" alt="解法"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="comment"># 异步</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    s1, s2 = head, head</span><br><span class="line">    <span class="keyword">while</span> s2 <span class="keyword">and</span> s2.<span class="built_in">next</span>:</span><br><span class="line">        s1 = s1.<span class="built_in">next</span></span><br><span class="line">        s2 = s2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> s1 == s2: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">or</span> <span class="keyword">not</span> s2.<span class="built_in">next</span>: <span class="keyword">return</span></span><br><span class="line">    s2 = head</span><br><span class="line">    <span class="keyword">while</span> s1 != s2:</span><br><span class="line">        s1 = s1.<span class="built_in">next</span></span><br><span class="line">        s2 = s2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 141. 环形链表</title>
    <url>/leetcode/141.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="comment"># 异步</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    s2, s1 = head.<span class="built_in">next</span>, head</span><br><span class="line">    <span class="keyword">while</span> s1 != s2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">or</span> <span class="keyword">not</span> s2.<span class="built_in">next</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s1 = s1.<span class="built_in">next</span></span><br><span class="line">        s2 = s2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 139. 单词拆分</title>
    <url>/leetcode/139.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    <span class="comment"># dfs</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">start</span>):</span><br><span class="line">        <span class="keyword">if</span> start == s_len: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.get(start, -<span class="number">1</span>) != -<span class="number">1</span>: <span class="keyword">return</span> cur.get(start, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">            s_c = s[start: i]</span><br><span class="line">            <span class="keyword">if</span> s_c <span class="keyword">in</span> word_set <span class="keyword">and</span> dfs(i):</span><br><span class="line">                cur[start] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        cur[start] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">    </span><br><span class="line">    s_len = <span class="built_in">len</span>(s)</span><br><span class="line">    word_set, cur = <span class="built_in">set</span>(wordDict), &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    <span class="comment"># bfs</span></span><br><span class="line">    i, s_len = <span class="number">1</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    word_set, cur, queue = <span class="built_in">set</span>(wordDict), <span class="built_in">set</span>(), [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        start = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> start <span class="keyword">in</span> cur: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[start: i] <span class="keyword">in</span> word_set:</span><br><span class="line">                <span class="keyword">if</span> i == s_len: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                queue.append(i)</span><br><span class="line">                </span><br><span class="line">        cur.add(start)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    s_len = <span class="built_in">len</span>(s)</span><br><span class="line">    dp, wordSet = [<span class="literal">False</span>] * (s_len + <span class="number">1</span>), <span class="built_in">set</span>(wordDict)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            cur = s[j: i]</span><br><span class="line">            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> cur <span class="keyword">in</span> wordSet:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    <span class="comment"># 动态规划优化</span></span><br><span class="line">    s_len = <span class="built_in">len</span>(s)</span><br><span class="line">    dp, wordSet = [<span class="literal">False</span>] * (s_len + <span class="number">1</span>), <span class="built_in">set</span>(wordDict)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> dp[i]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[j]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cur = s[j: i]</span><br><span class="line">            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> cur <span class="keyword">in</span> wordSet:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 136. 只出现一次的数字</title>
    <url>/leetcode/136.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 位运算</span></span><br><span class="line">    ret = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        ret = nums[i] ^ ret</span><br><span class="line">    <span class="keyword">return</span> ret </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 128. 最长连续序列</title>
    <url>/leetcode/128.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">nums</span>):</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    nums_set = <span class="built_in">set</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums_set:</span><br><span class="line">        <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cur, cur_num = <span class="number">1</span>, num + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur_num <span class="keyword">in</span> nums_set:</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">            cur_num += <span class="number">1</span></span><br><span class="line">        ret = <span class="built_in">max</span>(ret, cur)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">nums</span>):</span><br><span class="line">    num_dict, ret = &#123;&#125;, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> num_dict:</span><br><span class="line">            left = num_dict.get(num - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            right = num_dict.get(num + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            cur = left + right + <span class="number">1</span></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, cur)</span><br><span class="line"></span><br><span class="line">            num_dict[num] = cur</span><br><span class="line">            num_dict[num - left] = cur</span><br><span class="line">            num_dict[num + right] = cur</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>hash表</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 124. 二叉树中最大路径和</title>
    <url>/leetcode/124.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ret = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = order(node.left)</span><br><span class="line">            right = order(node.right)</span><br><span class="line">            self.ret = <span class="built_in">max</span>(left + node.val + right, self.ret)</span><br><span class="line">            cur = node.val + <span class="built_in">max</span>(<span class="number">0</span>, left, right)</span><br><span class="line">            <span class="keyword">return</span> cur <span class="keyword">if</span> cur &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        order(root)</span><br><span class="line">        <span class="keyword">return</span> self.ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 121. 买卖股票的最佳时机</title>
    <url>/leetcode/121.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    p_len = <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">if</span> p_len &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    profit, in_ = <span class="number">0</span>, prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p_len):</span><br><span class="line">        in_ = <span class="built_in">min</span>(prices[i], in_)</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, prices[i] - in_)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 114. 二叉树展开为链表</title>
    <url>/leetcode/114.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        order(node.left)</span><br><span class="line">        order(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            next_ = node.right <span class="keyword">if</span> node.right <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            node.left, node.right = <span class="literal">None</span>, node.left</span><br><span class="line">            <span class="keyword">if</span> next_:</span><br><span class="line">                cur = node.right</span><br><span class="line">                <span class="keyword">while</span> cur.right:</span><br><span class="line">                    cur = cur.right</span><br><span class="line">                cur.right = next_</span><br><span class="line">    order(root)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 105. 从前序与中序遍历序列构造二叉树</title>
    <url>/leetcode/105.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">preorder, inorder</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span> </span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">    root_idx = inorder.index(preorder.pop(<span class="number">0</span>))</span><br><span class="line">    root.left = self.buildTree(preorder[:root_idx], inorder[:root_idx])</span><br><span class="line">    root.right = self.buildTree(preorder[root_idx:], inorder[root_idx + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 104. 二叉树的最大深度</title>
    <url>/leetcode/104.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># dfs</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dfs(node.left), dfs(node.right)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dfs(root) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 102. 二叉树的层序遍历</title>
    <url>/leetcode/102.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res, cur = [], [root]</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cur)):</span><br><span class="line">            node = cur.pop(<span class="number">0</span>)</span><br><span class="line">            tmp.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: cur.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: cur.append(node.right)</span><br><span class="line">        res.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 101. 对称二叉树</title>
    <url>/leetcode/101.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val <span class="keyword">and</span> order(left.left, right.right) <span class="keyword">and</span> order(left.right, right.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> order(root, root)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 98. 验证二叉搜索树</title>
    <url>/leetcode/98.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">node, lower, upper</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        val = node.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> order(node.left, lower, val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> order(node.right, val, upper):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    ret = order(root, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 96. 不同的二叉搜索树</title>
    <url>/leetcode/96.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="/images/leetcode/leetcode96.jpeg" alt="动态规划"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):   <span class="comment"># 长度</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):   <span class="comment"># 根位置</span></span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 94. 二叉树的中序遍历</title>
    <url>/leetcode/94.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        order(node.left)</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        order(node.right)</span><br><span class="line">    res = []</span><br><span class="line">    order(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 85. 最大矩形</title>
    <url>/leetcode/85.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">and</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="comment"># 可转化为84. 柱状图中最大的矩形</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            width, area = dp[i][j], dp[i][j]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                width = <span class="built_in">min</span>(width, dp[k][j])</span><br><span class="line">                area = <span class="built_in">max</span>(area, (i - k + <span class="number">1</span>) * width)</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, area)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">and</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="comment"># 可转化为84. 柱状图中最大的矩形</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        left, right = [<span class="number">0</span>] * m, [<span class="number">0</span>] * m</span><br><span class="line"></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">while</span> tmp <span class="keyword">and</span> dp[tmp[-<span class="number">1</span>]][j] &gt;= dp[i][j]:</span><br><span class="line">                tmp.pop()</span><br><span class="line">            left[i] = tmp[-<span class="number">1</span>] <span class="keyword">if</span> tmp <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            tmp.append(i)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> tmp <span class="keyword">and</span> dp[tmp[-<span class="number">1</span>]][j] &gt;= dp[i][j]:</span><br><span class="line">                tmp.pop()</span><br><span class="line">            right[i] = tmp[-<span class="number">1</span>] <span class="keyword">if</span> tmp <span class="keyword">else</span> m</span><br><span class="line">            tmp.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, (right[i] - left[i] - <span class="number">1</span>) * dp[i][j])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 84. 柱状图中最大的矩形</title>
    <url>/leetcode/84.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双指针-动态规划"><a href="#双指针-动态规划" class="headerlink" title="双指针 + 动态规划"></a>双指针 + 动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights</span>):</span><br><span class="line">    <span class="comment"># 类似接雨水</span></span><br><span class="line">    res, h_len = <span class="number">0</span>, <span class="built_in">len</span>(heights)</span><br><span class="line">    dp_left, dp_right = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len)], [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h_len):</span><br><span class="line">        <span class="keyword">while</span> dp_left[i] &gt; <span class="number">0</span> <span class="keyword">and</span> heights[i] &lt;= heights[dp_left[i] - <span class="number">1</span>]:</span><br><span class="line">            dp_left[i] = dp_left[dp_left[i] - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(dp_left)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> dp_right[i] &lt; h_len - <span class="number">1</span> <span class="keyword">and</span> heights[i] &lt;= heights[dp_right[i] + <span class="number">1</span>]:</span><br><span class="line">            dp_right[i] = dp_right[dp_right[i] + <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(dp_right)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len):</span><br><span class="line">        res = <span class="built_in">max</span>(res, (dp_right[i] - dp_left[i] + <span class="number">1</span>) * heights[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights</span>):</span><br><span class="line">    <span class="comment"># 类似接雨水</span></span><br><span class="line">    res, h_len = <span class="number">0</span>, <span class="built_in">len</span>(heights)</span><br><span class="line">    left, right = [<span class="number">0</span>] * h_len, [<span class="number">0</span>] * h_len</span><br><span class="line"></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len):</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> heights[tmp[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">            tmp.pop()</span><br><span class="line">        left[i] = tmp[-<span class="number">1</span>] <span class="keyword">if</span> tmp <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        tmp.append(i)</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="comment"># print(left)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> heights[tmp[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">            tmp.pop()</span><br><span class="line">        right[i] = tmp[-<span class="number">1</span>] <span class="keyword">if</span> tmp <span class="keyword">else</span> h_len</span><br><span class="line">        tmp.append(i)</span><br><span class="line">    <span class="comment"># print(right)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h_len):</span><br><span class="line">        res = <span class="built_in">max</span>(res, (right[i] - left[i] - <span class="number">1</span>) * heights[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 79. 单词搜索</title>
    <url>/leetcode/79.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回溯思想-dfs-实现"><a href="#回溯思想-dfs-实现" class="headerlink" title="回溯思想 + dfs 实现"></a>回溯思想 + dfs 实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">board, word</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, k</span>):</span><br><span class="line">        <span class="comment"># 首先判断完成匹配与否</span></span><br><span class="line">        <span class="keyword">if</span> k == s_len:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断是否在数组内</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断是否匹配过</span></span><br><span class="line">        <span class="keyword">if</span> dp[i][j] == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断是否匹配得上</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] != word[k]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="comment"># 标记当前路线已匹配</span></span><br><span class="line">        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 匹配上了</span></span><br><span class="line">        <span class="keyword">if</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 准备下一路线匹配</span></span><br><span class="line">        dp[i][j] = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 没匹配上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    k, s_len = <span class="number">0</span>, <span class="built_in">len</span>(word)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找起始点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 找到起始点后, dfs</span></span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 78. 子集</title>
    <url>/leetcode/78.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回溯思想-dfs实现"><a href="#回溯思想-dfs实现" class="headerlink" title="回溯思想 + dfs实现"></a>回溯思想 + dfs实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, tmp</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= n_len:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        tmp.append(nums[i])</span><br><span class="line">        res.append(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n_len):</span><br><span class="line">            dfs(j, tmp.copy())</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    n_len = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = [[]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_len):</span><br><span class="line">        dfs(i, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 76. 最小覆盖子串</title>
    <url>/leetcode/76.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="hash表-滑动窗口"><a href="#hash表-滑动窗口" class="headerlink" title="hash表 + 滑动窗口"></a>hash表 + 滑动窗口</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="built_in">len</span>(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 构建hash表</span></span><br><span class="line">    hash_t, hash_s, count = &#123;&#125;, &#123;&#125;, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">        hash_t[c] = hash_t.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    j, t_len, res = <span class="number">0</span>, <span class="built_in">len</span>(t), <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        hash_s[s[i]] = hash_s.get(s[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> hash_s[s[i]] &lt;= hash_t.get(s[i], <span class="number">0</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= i <span class="keyword">and</span> hash_s.get(s[j], <span class="number">0</span>) &gt; hash_t.get(s[j], <span class="number">0</span>):</span><br><span class="line">            hash_s[s[j]] -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == t_len:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> i - j + <span class="number">1</span> &lt; <span class="built_in">len</span>(res):</span><br><span class="line">                res = s[j: i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash表</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 75. 颜色分类</title>
    <url>/leetcode/75.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双指针-快排"><a href="#双指针-快排" class="headerlink" title="双指针 + 快排"></a>双指针 + 快排</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 双指针 + 快排</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[left] &lt; nums[j]: j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[left] &gt;= nums[i]: i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">        quick_sort(left, i - <span class="number">1</span>)</span><br><span class="line">        quick_sort(i + <span class="number">1</span>, right)</span><br><span class="line">    </span><br><span class="line">    quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="单指针"><a href="#单指针" class="headerlink" title="单指针"></a>单指针</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recover</span>(<span class="params">n_len, p, target</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_len):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                nums[i], nums[p] = nums[p], nums[i]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="comment"># 单指针遍历</span></span><br><span class="line">    n_len, point = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">    <span class="comment"># 复位0</span></span><br><span class="line">    point = recover(n_len, point, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 复位1</span></span><br><span class="line">    point = recover(n_len, point, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="双指针1"><a href="#双指针1" class="headerlink" title="双指针1"></a>双指针1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 双指针遍历</span></span><br><span class="line">    p0, p2, i = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= p2:</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">            p0 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">            nums[i], nums[p2] = nums[p2], nums[i]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != <span class="number">1</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="双指针2"><a href="#双指针2" class="headerlink" title="双指针2"></a>双指针2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 双指针遍历</span></span><br><span class="line">    p0, p1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">            nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">            <span class="keyword">if</span> p0 &lt; p1:</span><br><span class="line">                nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">            p0 += <span class="number">1</span></span><br><span class="line">            p1 += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>快排</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 1143. 最长公共子序列</title>
    <url>/leetcode/1143.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1) + <span class="number">1</span>, <span class="built_in">len</span>(text2) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> j != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 72. 编辑距离</title>
    <url>/leetcode/72.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="/images/leetcode/leetcode72.jpg" alt="编辑距离: 动态规划"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> m * n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> m + n</span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> word2[i - <span class="number">1</span>] != word1[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 70. 爬楼梯</title>
    <url>/leetcode/70.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划-一维数组"><a href="#动态规划-一维数组" class="headerlink" title="动态规划 + 一维数组"></a>动态规划 + 一维数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="动态规划-两个数"><a href="#动态规划-两个数" class="headerlink" title="动态规划 + 两个数"></a>动态规划 + 两个数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 64. 最小路径和</title>
    <url>/leetcode/64.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划-二维数组"><a href="#动态规划-二维数组" class="headerlink" title="动态规划 + 二维数组"></a>动态规划 + 二维数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">grid</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = grid[i][j]</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<h1 id="动态规划-一维数组"><a href="#动态规划-一维数组" class="headerlink" title="动态规划 + 一维数组"></a>动态规划 + 一维数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">grid</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [<span class="number">0</span>] * n </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[j] = grid[i][j]</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = grid[i][j] + <span class="built_in">min</span>(dp[j - <span class="number">1</span>], dp[j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 62. 不同路径</title>
    <url>/leetcode/62.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划-二维数组"><a href="#动态规划-二维数组" class="headerlink" title="动态规划 - 二维数组"></a>动态规划 - 二维数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">m, n</span>):</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>: </span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="动态规划-一维数组"><a href="#动态规划-一维数组" class="headerlink" title="动态规划 - 一维数组"></a>动态规划 - 一维数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">m, n</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>: </span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 56. 合并区间</title>
    <url>/leetcode/56.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    intervals = <span class="built_in">sorted</span>(intervals, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> inter <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret <span class="keyword">or</span> ret[-<span class="number">1</span>][<span class="number">1</span>] &lt; inter[<span class="number">0</span>]:</span><br><span class="line">            ret.append(inter)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ret[-<span class="number">1</span>][<span class="number">1</span>], inter[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 55. 跳跃游戏</title>
    <url>/leetcode/55.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">nums</span>):</span><br><span class="line">    n_len = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n_len == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n_len - <span class="number">1</span>) </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> dp[<span class="number">0</span>] == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_len - <span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], i + nums[i])</span><br><span class="line">        <span class="keyword">if</span> dp[i] == i:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>] &gt;= n_len - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="优化动态规划-x3D-x3D-贪心"><a href="#优化动态规划-x3D-x3D-贪心" class="headerlink" title="优化动态规划 &#x3D;&#x3D; 贪心"></a>优化动态规划 &#x3D;&#x3D; 贪心</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">nums</span>):</span><br><span class="line">    n_len = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n_len == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    max_hop = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> max_hop == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_len - <span class="number">1</span>):</span><br><span class="line">        max_hop = <span class="built_in">max</span>(max_hop, i + nums[i])</span><br><span class="line">        <span class="keyword">if</span> max_hop == i:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> max_hop &gt;= n_len - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 53. 最大子数组和</title>
    <url>/leetcode/53.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    cur, ret = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        cur = <span class="built_in">max</span>(n, cur + n)</span><br><span class="line">        ret = <span class="built_in">max</span>(cur, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 49. 字母异位词分组</title>
    <url>/leetcode/49.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="排序-hash表"><a href="#排序-hash表" class="headerlink" title="排序 + hash表"></a>排序 + hash表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">strs</span>):</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        cur = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(s))</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">in</span> dic.keys():</span><br><span class="line">            dic[cur].append(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dic[cur] = [s]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(dic.values())    </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 48. 旋转图像</title>
    <url>/leetcode/48.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="矩阵处理-转置-列调换"><a href="#矩阵处理-转置-列调换" class="headerlink" title="矩阵处理(转置 + 列调换)"></a>矩阵处理(转置 + 列调换)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    height = <span class="built_in">len</span>(matrix)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, height):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height // <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            matrix[j][i], matrix[j][height - <span class="number">1</span> - i] = matrix[j][height - <span class="number">1</span> - i],  matrix[j][i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 46. 全排列</title>
    <url>/leetcode/46.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">ret, num</span>):</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> ret:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(r) + <span class="number">1</span>):</span><br><span class="line">                tmp.append(r[:i] + [num] + r[i:])</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ret = [[nums[<span class="number">0</span>]]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        ret = add(ret, nums[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 42. 接雨水</title>
    <url>/leetcode/42.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="按列求-N-x2F-A"><a href="#按列求-N-x2F-A" class="headerlink" title="按列求 N&#x2F;A"></a>按列求 N&#x2F;A</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">height</span>):</span><br><span class="line">    <span class="comment"># 按列求</span></span><br><span class="line">    ret, h_len = <span class="number">0</span>, <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h_len - <span class="number">1</span>):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            left = <span class="built_in">max</span>(height[l], left)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, h_len):</span><br><span class="line">            right = <span class="built_in">max</span>(right, height[r])</span><br><span class="line">        </span><br><span class="line">        cur = <span class="built_in">min</span>(left, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur &gt; height[i]:</span><br><span class="line">            ret += (cur - height[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>


<h1 id="动态规划-按列求"><a href="#动态规划-按列求" class="headerlink" title="动态规划 + 按列求"></a>动态规划 + 按列求</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">height</span>):</span><br><span class="line">    <span class="comment"># 动态规划 + 按列求</span></span><br><span class="line">    ret, h_len = <span class="number">0</span>, <span class="built_in">len</span>(height)</span><br><span class="line">    left, right = [<span class="number">0</span>] * h_len, [<span class="number">0</span>] * h_len</span><br><span class="line">    left[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h_len):</span><br><span class="line">        left[l] = <span class="built_in">max</span>(left[l - <span class="number">1</span>], height[l])</span><br><span class="line">    right[h_len - <span class="number">1</span>] = height[h_len - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(h_len - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        right[r] = <span class="built_in">max</span>(right[r + <span class="number">1</span>], height[r])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h_len - <span class="number">1</span>):</span><br><span class="line">        cur = <span class="built_in">min</span>(left[i], right[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur &gt; height[i]:</span><br><span class="line">            ret += (cur - height[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>


<h1 id="双指针-按列求"><a href="#双指针-按列求" class="headerlink" title="双指针 + 按列求"></a>双指针 + 按列求</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">height</span>):</span><br><span class="line">    <span class="comment"># 双指针 + 按列求</span></span><br><span class="line">    ret, h_len = <span class="number">0</span>, <span class="built_in">len</span>(height)</span><br><span class="line">    max_left, max_right = height[<span class="number">0</span>], height[h_len - <span class="number">1</span>]</span><br><span class="line">    left, right = <span class="number">1</span>, h_len - <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h_len - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> height[left - <span class="number">1</span>] &lt; height[right + <span class="number">1</span>]:</span><br><span class="line">            max_left = <span class="built_in">max</span>(max_left, height[left - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> max_left &gt; height[left]:</span><br><span class="line">                ret += (max_left - height[left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_right = <span class="built_in">max</span>(max_right, height[right + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> max_right &gt; height[right]:</span><br><span class="line">                ret += (max_right - height[right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>


<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">height</span>):</span><br><span class="line">    <span class="comment"># 栈</span></span><br><span class="line">    ret, h_len = <span class="number">0</span>, <span class="built_in">len</span>(height)</span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h_len):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">            bottom = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                ret += (<span class="built_in">min</span>(height[stack[-<span class="number">1</span>]], height[i]) - height[bottom]) * (i - stack[-<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">        stack.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 39. 组合总和</title>
    <url>/leetcode/39.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回溯思想-dfs实现"><a href="#回溯思想-dfs实现" class="headerlink" title="回溯思想, dfs实现"></a>回溯思想, dfs实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span> []</span><br><span class="line">    res, cand_len = [], <span class="built_in">len</span>(candidates)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">target, combins, idx, begin</span>):</span><br><span class="line">        target -= candidates[idx]</span><br><span class="line">        combins.append(candidates[idx])</span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(combins)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, cand_len):</span><br><span class="line">            dfs(target, combins.copy(), i, i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cand_len):</span><br><span class="line">        dfs(target, [], i, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>SwinTextSpotter - Scene Text Spotting via Better Synergy between Text Detection and Text Recognition</title>
    <url>/paper/swin_text_spotter.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>论文地址: <a href="https://openaccess.thecvf.com/content/CVPR2022/papers/Huang_SwinTextSpotter_Scene_Text_Spotting_via_Better_Synergy_Between_Text_Detection_CVPR_2022_paper.pdf">Huang_SwinTextSpotter_Scene_Text_Spotting_via_Better_Synergy_Between_Text_Detection_CVPR_2022_paper.pdf</a></p>
<p>代码地址: <a href="https://github.com/mxin262/SwinTextSpotter">SwinTextSpotter</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ol>
<li><p>近年来SOTA的文字定位方法仅仅是把从backbone得到的特征, 输送到检测与识别分支, 并没有直接利用两个任务之间的特征交互.</p>
</li>
<li><p>SwinTextSpotter: 端到端的文字定位框架. 使用动态头的Transformer编码器作为检测器, 此次工作将这两个任务与一种新的识别转换机制统一起来，通过识别损失明确指导文本定位.</p>
</li>
<li><p>这样直接的设计产生了一个简洁的框架，既不需要额外的纠正模块，也不需要对任意形状的文本进行字符级注释.</p>
</li>
</ol>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>传统的文字定位方法把检测和识别视作两个分离的任务. 首先, 从输入图像上定位并裁剪出文本区域, 然后把裁剪的区域送入文本识别器预测文本序列.</p>
<p>这样的框架会有以下限制:</p>
<ol>
<li><p>两个任务的误差累加. eg: 不精确的检测结果会严重影响文字识别的性能.</p>
</li>
<li><p>检测与分割两个任务的各自优化或许不会使得文字定位得到最好的效果.</p>
</li>
<li><p>内存消耗大, 推理效率低.</p>
</li>
</ol>
<p>为解决以上限制, 现尝试在一个端到端的框架解决文字定位问题.</p>
<p>现存这样的框架同样存在限制:</p>
<ol>
<li><p>如果检测仅仅基于输入特征的视觉信息, 检测器容易被背景噪声分散注意力并提出不一致的检测.</p>
</li>
<li><p>检测和识别之间的交互通过共享backbone是不够的, 因为检测器既没有优化识别损失, 识别器也没有利用检测特征.</p>
</li>
</ol>
<p>此次工作提出<strong>SwinTextSpotter</strong>, 是一个端到端训练, 基于Transformer的框架.</p>
<p>为了更好的区别拥挤场景中密集分散的文本实例, 在<strong>SwinTextSpotter</strong>中使用Transformer和两层自注意力机制激励文本实例之间的交互.</p>
<p>为了解决任意形状场景文字定位, 把文本检测任务视作集合预测问题, 然后使用基于查询的文字检测器.</p>
<p>此次工作进一步提出了<strong>识别转换RC</strong>模块, 它通过结合检测特征隐式地引导识别头. <strong>识别转换RC</strong>模块可以反向传播识别信息到检测器, 并且抑制识别特征中的背景噪声, 引导检测器与识别器的联合优化.</p>
<p>通过使用<strong>识别转换RC</strong>模块, <strong>SwinTextSpotter</strong>是一个简洁的框架, 没有先前工作中用于提升识别器的字符及注释和矫正模块.</p>
<p>此次工作主要贡献总结如下:</p>
<ol>
<li><p><strong>SwinTextSpotter</strong>开创性的展示了Transformer和集合预测在端到端场景文字预测的有效性.</p>
</li>
<li><p><strong>SwinTextSpotter</strong>使用了<strong>识别转换RC</strong>模块来利用文字检测和识别之间的协同作用.</p>
</li>
<li><p><strong>SwinTextSpotter</strong>是一个简单的框架, 既不需要字符级别的注释, 也不需要为了识别任意形状的文字设计修正模块.</p>
</li>
<li><p><strong>SwinTextSpotter</strong>在多个公共场景文字基准上实现了SOTA性能.</p>
</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><span id="model"><img src="/images/swinTextSpotter_img/model.png" alt="图1: SwinTextSpotter model"></span></p>
<p><strong>SwinTextSpotter</strong>模型的整体结构如<a href="#model">图1</a>所示.它包含四个组件:</p>
<ol>
<li>基于Swin-Transformer的backbone,</li>
<li>基于查询的文字检测器,</li>
<li>连接文字检测器和识别器的<strong>识别转换RC</strong>模块,</li>
<li>基于注意力的识别器.</li>
</ol>
<p>如<a href="#model">图1</a>绿色箭头所示, <strong>检测</strong>的第一阶段, 首先随机初始化训练参数作为box$ bbox_{0} $和proposal特征$ f_{0}^{prop} $.</p>
<p>为了proposal特征能够获得全局信息, 使用全局平均池化提取图像特征, 并把他们加入到$ f_{0}^{prop} $中.</p>
<p>然后使用$ bbox_{0} $提取ROI特征.</p>
<p>把ROI特征和$ f_{0}^{prop} $送入带动态头的Transformer编码器中.</p>
<p>Transformer编码器的输出展开并命名为$ f_{1}^{prop} $, 送入检测头输出检测结果.</p>
<p>box$ bbox_{k - 1} $和proposal特征$ f_{k - 1}^{prop} $作为第$ k^{th} $个阶段检测器的输入.</p>
<p>proposal特征$ f_{k}^{prop} $通过融合ROI特征与之前的$ f_{k - 1}^{prop} $来反复更新自己, 这样使得proposal特征保存了先前阶段的信息.</p>
<p>此次工作对总计$ K $个阶段重复这样的细化, 类似与基于查询检测器的迭代结构.</p>
<p>这样的设计使得在尺寸和纵横比方面进行更加鲁棒的检测.</p>
<p>在<strong>识别阶段</strong>, <a href="#model">图1</a>即橙色箭头所示, 相较于检测, 需要更高的分辨率.</p>
<p>此次工作使用检测的第$ K $个阶段的输出box$ bbox_{k} $来获取ROI特征, 此时的分辨率是检测阶段的四倍.</p>
<p>为了在融合proposal特征时保持分辨率与检测器一致, 对ROI特征进行下采样, 得到三个尺寸递减的特征图, 以$ \lbrace a_1, a_2, a_3 \rbrace $表示.</p>
<p>通过融合最小的$ a_3 $和proposal特征$ f_{K}^{prop} $得到检测特征$ f^{det} $.</p>
<p>在识别阶段, 检测特征$ f^{det} $包含先前所有的检测信息.</p>
<p>最终, $ \lbrace a_1, a_2, a_3 \rbrace $和检测特征$ f^{det} $送入<strong>识别转换RC</strong>模块以及为了生成识别结果的识别器中.</p>
<h2 id="Dilated-Swin-Transformer"><a href="#Dilated-Swin-Transformer" class="headerlink" title="Dilated Swin-Transformer"></a>Dilated Swin-Transformer</h2><p><span id="Dilated_Swin_Transformer"><img src="/images/swinTextSpotter_img/Dilated_Swin_Transformer.png" alt="图2: Dilated Swin Transformer"></span></p>
<p>对于文字定位, 建模不同文字之间的关系是十分重要的, 因为同一张图像上的文字有着极强的相似性, 例如其背景和样式.</p>
<p>考虑到全局建模能力和计算效率, 使用FPN + Swin-Transformer作为backbone. </p>
<p>鉴于一行文字字之间存在空白, 感受野需要足够大来帮助区分来相邻文字是否属于同一文本行.</p>
<p>为了获得这样的感受野, 在原始Swin-Transformer中使用了两个空洞卷积, 一个普通卷积和一个残差结构, 如<a href="#Dilated_Swin_Transformer">图2</a>所示, 这样也把CNN的属性引入Transformer中.</p>
<h2 id="基于查询的检测器"><a href="#基于查询的检测器" class="headerlink" title="基于查询的检测器"></a>基于查询的检测器</h2><p>使用基于查询的检测器检测文本, 基于查询的检测器建立在ISTR之上, 把检测视为一个集合预测问题.</p>
<p>检测器使用一个proposal boxes集合, 用来替代RPN的庞大候选集, 一个proposal 特征集合表示目标的高阶语义向量.</p>
<p>检测器根据经验设计为具有六个查询阶段.</p>
<p>用动态头的Transformer编码器, 使得后续的阶段可以获得存储在proposal特征中的之间阶段的信息.</p>
<p>通过多个阶段的微调, 检测器可以适用于任何尺寸.</p>
<p><span id="detection_head"><img src="/images/swinTextSpotter_img/detectionAtKStage.png" alt="图3: k Stage detection head"></span></p>
<p>检测器在$ k^{th} $阶段的结构如<a href="#detection_head">图2</a>所示.</p>
<p>$ k - 1 $阶段的输出: proposal 特征$ f_{k - 1}^{prop} \in \mathbb{R}^{N, d} $在$ k^{th} $阶段输入到自注意力模块$ MSA_{k} $来建模关系, 并生成两个卷积的参数. 因此, 先前阶段的检测信息嵌入到卷积之中.</p>
<p>以先前的proposal特征为约束的卷积用来编码ROI特征.</p>
<p>$ k - 1 $阶段的输出: $ bbox_{k - 1} $, 利用其在RoI Aligin模块提取ROI特征, ROI特征输入到卷积层中, 然后输入到线性映射中, 生成下一个阶段的输入$ f_{k}^{prop} $.</p>
<p>$ f_{k}^{prop} $ 接着输入到预测头中生成$ bbox_{k} $和$ mask_{k} $.</p>
<p>为了减少计算, 2D mask 通过主成分分析(PCA)转换为 1D mask向量.</p>
<p>当 $ k &#x3D; 1 $时, $ bbox_{0} $和$ f_{0}^{prop} $是随机初始化的参数, 作为输入. </p>
<p>在整个训练过程中, 这些参数仅仅通过反向传播进行更新, 学习文本高级语义特征的归纳偏置.</p>
<p>整个文本检测任务是做一个集合预测问题. 使用二分匹配来匹配预测和真值.如$ 式 \eqref{eq:one} $.</p>
<p>$$ L_{match} &#x3D; \lambda_{cls} \cdot L_{cls} + \lambda_{L1} \cdot L_{L1} + \lambda_{giou} \cdot L_{giou} + \lambda_{mask} \cdot L_{mask} \tag{1} \label{eq:one}$$</p>
<p>其中, $ \lambda $是用于平衡损失的超参数, $ L_{cls} $是focal 损失, $ L_{L1} $损失是用于回归检测框的L1 损失, $ L_{giou} $ 是generalized IoU 损失, $ L_{mask} $本应计算预测mask和真值之间的余弦相似度, 但检测损失与匹配成本相似，改用 L2 损失和dice 损失来代替余弦相似度.</p>
<h2 id="识别转换RC模块"><a href="#识别转换RC模块" class="headerlink" title="识别转换RC模块"></a><strong>识别转换RC</strong>模块</h2><p><span id="rc"><img src="/images/swinTextSpotter_img/RC.png" alt="图4: RC模块"></span></p>
<p>为了更好地协同检测与识别, <strong>识别转换RC</strong>模块被用来在空间上结合从检测头得到的特征到识别阶段, 如<a href="#rc">图4</a>所示.</p>
<p><strong>识别转换RC</strong>模块由Transformer 编码器和四个上采样结构组成.</p>
<p><strong>识别转换RC</strong>模块的输入是检测特征$ f^{det} $和三个下采样特征$ \lbrace a_1, a_2, a_3 \rbrace $.</p>
<p>检测特征输送到Transformer 编码器$ TrE() $中, 使得先前检测阶段的信息与$ a_3 $进一步融合, 然后进行一系列上采样操作$ E_{u}() $和Sigmoid函数$ \phi() $, 生成三个文本区域掩码$ \lbrace M_1, M_2, M_3 \rbrace $.</p>
<p>$$ d_{1} &#x3D; TrE(f^{det}) \tag{2} \label{eq:two} $$</p>
<p>$$ d_{2} &#x3D; (E_{u}(d_{1}) + a_{2}) \tag{3} \label{eq:three} $$</p>
<p>$$ d_{3} &#x3D; (E_{u}(d_{2}) + a_{1}) \tag{4} \label{eq:four} $$</p>
<p>$$M_{i} &#x3D; \phi (d_{i}), i&#x3D;1,2,3. \tag{5} \label{eq:five} $$</p>
<p>进一步有效整合文本区域掩码$ \lbrace M_1, M_2, M_3 \rbrace $和输入特征$ \lbrace a_1, a_2, a_3 \rbrace $:</p>
<p>$$ r_1 &#x3D; M_1 \cdot a_3, \tag{6} \label{eq:six} $$</p>
<p>$$ r_2 &#x3D; M_2 \cdot (E_u(r_1) +a_2), \tag{7} \label{eq:seven} $$</p>
<p>$$ r_3 &#x3D; M_3 \cdot (E_u(r_2) +a_1), \tag{8} \label{eq:eight} $$</p>
<p>其中, $ {r_1, r_2, r_3} $表示识别特征. $ r_3 $ 如<a href="#rc">图4</a>所示, 是最终的融合特征, 会输送到最高分辨率的识别器中.</p>
<p>如<a href="#rc">图4</a>蓝色虚线所示, 识别损失$ L_{reg} $的梯度能够反向传播到检测特征中, 使得RC通过识别监督隐式改进检测头.</p>
<p>一般来说, 为了抑制背景, 融合特征会乘以检测头的输出$ L_{mask} $. 然而, 检测框不够精细, 特征图中仍然存在背景噪声. 这个问题可以通过RC模块缓解, 因为RC可以通过使用检测特征生成精细掩码抑制背景噪声, 整个过程受识别损失和检测损失监督.</p>
<p>如<a href="#rc">图4</a>右上角所示, $ M_3 $相较于$ mask_{K} $更能抑制背景噪声, $ M_3 $在文本区域有着更高的激活, 在背景区域有着更低的激活.因此, RC模块输出的掩码$ \lbrace M_1, M_2, M_3 \rbrace $可以应用于识别特征$ \lbrace r_1, r_2, r_3 \rblace $, 使得识别器更好地专注于文本区域.</p>
<p>使用RC模块, 识别损失的梯度不仅可以影响backbone网络, 也会影响proposal特征.</p>
<p>通过检测和识别监督优化, proposal特征能够更好的编码文本高阶语义信息.因此, RC模块可以激励检测与识别之间的协调.</p>
<h1 id="识别器"><a href="#识别器" class="headerlink" title="识别器"></a>识别器</h1><p>在特征图使用RC模块后, 背景噪声被有效抑制, 因此文本区域的框定更加精细. 这使得仅仅使用序列识别网络就可以得到有保证的识别结果, 而不需要矫正模块或字符级分割模块.</p>
<p>为了增强细粒度特征提取和序列建模，采用了双层自注意机制作为识别编码器.</p>
<p>两级自注意力机制分别包含局部邻域区域和全局区域的细粒度和粗粒度自注意力机制. 因此, 可以在维持全局建模能力的同时有效提取细粒度特征. </p>
<p>解码器使用SAM.</p>
<p>识别损失如$ 式 \eqref{eq:nine} $.</p>
<p>$$ L_{reg} &#x3D; -\frac{1}{T} \sum_{k &#x3D; 1}^{T} \log p(y_i) \tag{9} \label{eq: nine} $$</p>
<p>其中, $ T $是序列的最大长度, $ p(y_i) $是序列概率.</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>在ROIC3, ICDAR 2015, ReCTS, Vintext, Total-Text, SCUT-CTW 1500数据集上进行实验.</p>
<p><a href="#table1">表1</a>是模型在ICDAR 2015数据集上的结果, S, W和G分别代表强,弱和通用词典的识别.</p>
<p><span id="table1"><img src="/images/swinTextSpotter_img/table1.png" alt="Table1: ICDAR 2015"></span></p>
<p><a href="#table2">表2</a>是模型在ReCTS数据集上的结果, P, R, H分别表示准确率, 召回率和H-mean.</p>
<p><span id="table2"><img src="/images/swinTextSpotter_img/table2.png" alt="Table2: ReCTS"></span></p>
<p><a href="#table3">表3</a>是模型在RoIC13数据集上的结果, P, R, H分别表示准确率, 召回率和H-mean.</p>
<p><span id="table3"><img src="/images/swinTextSpotter_img/table3.png" alt="Table3: RoIC13"></span></p>
<p><a href="#table4">表4</a>是模型在VinText数据集上的结果.</p>
<p><span id="table4"><img src="/images/swinTextSpotter_img/table4.png" alt="Table4: VinText"></span></p>
<p><a href="#table5">表5</a>是模型在Total-Text数据集上的结果.</p>
<p><span id="table5"><img src="/images/swinTextSpotter_img/table5.png" alt="Table5: Total-Text"></span></p>
<p><a href="#table6">表6</a>是模型在SCUT-CTW1500数据集上的结果.</p>
<p><span id="table6"><img src="/images/swinTextSpotter_img/table6.png" alt="Table6: SCUT-CTW1500"></span></p>
<p><a href="#table7">表7</a>是模型的消融实验.</p>
<p><span id="table7"><img src="/images/swinTextSpotter_img/abl.png" alt="Table7: 消融实验"></span></p>
<p><a href="#vis">图5</a>是模型的消融实验.</p>
<p><span id="vis"><img src="/images/swinTextSpotter_img/vis.png" alt="图5: 结果可视化"></span></p>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>对于长任意形状文本的识别有限制. 长任意形状文本的识别需要分辨率高的特征图, 当特征图越大, 在识别器中的注意力图也会随之扩张. 大的注意力图可能会导致识别器的不匹配, 从而导致端到端文字定位性能的下降.</p>
]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>文字定位</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/leetcode/34.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="左右二分查找"><a href="#左右二分查找" class="headerlink" title="左右二分查找"></a>左右二分查找</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="comment"># 左右二分</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_left</span>(<span class="params">l, r, t</span>):</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; t:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_right</span>(<span class="params">l, r, t</span>): </span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; t:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">    nums_len = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    left = search_left(<span class="number">0</span>, nums_len, target)</span><br><span class="line">    right = search_right(<span class="number">0</span>, nums_len, target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [left, right] <span class="keyword">if</span> nums[left] == target <span class="keyword">and</span> nums[right] == target <span class="keyword">else</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 33. 搜索旋转排序树组</title>
    <url>/leetcode/33.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 数组是局部有序的</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + right &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># [l, mid - 1] 有序</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]:</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># [mid + 1, right] 有序</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 32. 最长有效括号</title>
    <url>/leetcode/32.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>dp[i] 表示到第i个字符的有效括号数量<br>初始情况下, 全部初始化为0</p>
<ol>
<li>s[i - 1], s[i] &#x3D;&#x3D; “()”<br>dp[i] &#x3D; dp[i - 2] + 2</li>
<li>s[i - 1], s[i] &#x3D;&#x3D; “…))”<br> dp[i] &#x3D; dp[i - dp[i - 1] - 1] + dp[i - 2] + 2 if s[i - dp[i - 1] - 1] &#x3D;&#x3D; “(“<br>代码还需考虑 i 的范围的事情</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    s_len = <span class="built_in">len</span>(s)</span><br><span class="line">    dp, max_sub = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(s_len)], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> i - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span> <span class="keyword">if</span> i - <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">        max_sub = <span class="built_in">max</span>(max_sub, dp[i])</span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    <span class="keyword">return</span> max_sub</span><br></pre></td></tr></table></figure>


<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><ol>
<li><p>对于遇到的每个”(“, 将它的下标放入栈中</p>
</li>
<li><p>对于遇到的每个”)”, 先弹出栈顶元素表示匹配了当前右括号:</p>
<ol>
<li>如果栈为空，说明当前的右括号为没有被匹配的右括号，将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li>
</ol>
</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 栈</span></span><br><span class="line">    stack, max_sub = [-<span class="number">1</span>], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                max_sub = <span class="built_in">max</span>(max_sub, i - stack[-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sub</span><br></pre></td></tr></table></figure>


<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 贪心</span></span><br><span class="line">    left, right, max_sub, s_len = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            max_sub = <span class="built_in">max</span>(max_sub, right * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            max_sub = <span class="built_in">max</span>(max_sub, right * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> left &gt; right:</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sub</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 224. 基本计算器</title>
    <url>/leetcode/224.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="栈处理op"><a href="#栈处理op" class="headerlink" title="栈处理op"></a>栈处理op</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">s</span>):</span><br><span class="line">    op = [<span class="number">1</span>]</span><br><span class="line">    sign, res = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    i, s_len = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">while</span> i &lt; s_len:</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            sign = op[-<span class="number">1</span>]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            sign = -op[-<span class="number">1</span>]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            op.append(sign)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            op.pop()</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; s_len <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res += sign * num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res   </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题 基础计算器</title>
    <url>/leetcode/writtten_exam1.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个表达式计算, 输入包括: 非负整数, “(“, “)”, “+”, “-“, “*”, “&#x2F;“, 空格</p>
<p>示例</p>
<blockquote>
<p>“2 * ( 6 - 1 ) &#x2F; 4”</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>2</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>实际上是中缀表达式的计算, 中缀转后缀计算</p>
<h1 id="栈-hash"><a href="#栈-hash" class="headerlink" title="栈 + hash"></a>栈 + hash</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    prior = &#123;<span class="string">&quot;+&quot;</span>: <span class="number">0</span>, <span class="string">&quot;-&quot;</span>: <span class="number">0</span>, <span class="string">&quot;*&quot;</span>: <span class="number">1</span>, <span class="string">&quot;/&quot;</span>: <span class="number">1</span>, <span class="string">&quot;(&quot;</span>: -<span class="number">1</span>&#125;</span><br><span class="line">    stack, op = [], []</span><br><span class="line">    num = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 中缀 -&gt; 后缀</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">&quot; &quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                num = <span class="number">10</span> * num + <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> num != <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">int</span>(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> num != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                    num = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> op:</span><br><span class="line">                    <span class="keyword">if</span> s[i] != <span class="string">&quot;(&quot;</span> <span class="keyword">and</span> s[i] != <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                        <span class="keyword">while</span> op <span class="keyword">and</span> prior[s[i]] &lt;= prior[op[-<span class="number">1</span>]]:</span><br><span class="line">                            stack.append(op.pop())</span><br><span class="line">                        op.append(s[i])</span><br><span class="line">                    <span class="keyword">elif</span> s[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                        op.append(s[i])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">while</span> op <span class="keyword">and</span> op[-<span class="number">1</span>] != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                            stack.append(op.pop())</span><br><span class="line">                        op.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    op.append(s[i])</span><br><span class="line">    <span class="keyword">if</span> num != <span class="literal">None</span>: stack.append(num)</span><br><span class="line">    <span class="keyword">while</span> op: stack.append(op.pop())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(stack)</span></span><br><span class="line">    <span class="comment"># 计算后缀</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> cur <span class="keyword">in</span> stack:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(cur) == <span class="built_in">int</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num2, num1 = res.pop(), res.pop()</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                tmp = num1 + num2</span><br><span class="line">            <span class="keyword">elif</span> cur ==<span class="string">&quot;-&quot;</span>:</span><br><span class="line">                tmp = num1 - num2</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                tmp = num1 * num2</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = num1 / num2</span><br><span class="line">            res.append(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[-<span class="number">1</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<h1 id="扩展-前缀表达式的计算"><a href="#扩展-前缀表达式的计算" class="headerlink" title="扩展: 前缀表达式的计算"></a>扩展: 前缀表达式的计算</h1><p>前缀不需要转换, 利用<strong>栈</strong>对表达式从右到左扫描计算</p>
]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>校招</tag>
        <tag>hash表</tag>
        <tag>栈</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 31. 下一个排列</title>
    <url>/leetcode/31.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="类似双指针"><a href="#类似双指针" class="headerlink" title="类似双指针"></a>类似双指针</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">核心是保证变大的幅度尽可能小</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">        i = <span class="built_in">len</span>(nums) - <span class="number">2</span></span><br><span class="line">        <span class="comment"># 求最靠右的较小数</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i + <span class="number">1</span>]: i-= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 求最远离较小数的较大数</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;= <span class="number">0</span>:</span><br><span class="line">            j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; i <span class="keyword">and</span> nums[j] &lt;= nums[i]: j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 交换较大较小数</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保证变大幅度不大的降序反序</span></span><br><span class="line">        l, r = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">                </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 23. 合并K个升序链表</title>
    <url>/leetcode/23.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="预置"><a href="#预置" class="headerlink" title="预置"></a>预置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>


<h1 id="队列-leetcode-21"><a href="#队列-leetcode-21" class="headerlink" title="队列 + leetcode 21"></a>队列 + leetcode 21</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">lists</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergelal</span>(<span class="params">l1, l2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        top = ListNode()</span><br><span class="line">        cur, c1, c2 = top, l1, l2</span><br><span class="line">        <span class="keyword">while</span> c1 <span class="keyword">and</span> c2:</span><br><span class="line">            <span class="keyword">if</span> c1.val &lt;= c2.val:</span><br><span class="line">                cur.<span class="built_in">next</span>, c1 = c1, c1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span>, c2 = c2, c2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> c1: cur.<span class="built_in">next</span> = c1</span><br><span class="line">        <span class="keyword">if</span> c2: cur.<span class="built_in">next</span> = c2</span><br><span class="line">        <span class="keyword">return</span> top.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(lists) &gt; <span class="number">1</span>:</span><br><span class="line">        lists.append(mergelal(lists.pop(<span class="number">0</span>), lists.pop(<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>] </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 22. 括号生成</title>
    <url>/leetcode/22.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回溯思想-深度优先遍历-dfs-实现"><a href="#回溯思想-深度优先遍历-dfs-实现" class="headerlink" title="回溯思想 + 深度优先遍历(dfs)实现"></a>回溯思想 + 深度优先遍历(dfs)实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    res, cur = [], <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            res.append(cur)</span><br><span class="line">        <span class="keyword">elif</span> right &lt; left:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(cur + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(cur + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>)</span><br><span class="line">    dfs(cur, n, n) </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 21. 合并两个有序链表</title>
    <url>/leetcode/21.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="预置"><a href="#预置" class="headerlink" title="预置"></a>预置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="虚拟头节点-链表基础操作"><a href="#虚拟头节点-链表基础操作" class="headerlink" title="虚拟头节点 + 链表基础操作"></a>虚拟头节点 + 链表基础操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">list1, list2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> list1: <span class="keyword">return</span> list2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1</span><br><span class="line">    top = ListNode()</span><br><span class="line">    cur1, cur2, cur = list1, list2, top</span><br><span class="line">    <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">        <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">            cur.<span class="built_in">next</span>, cur1 = cur1, cur1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span>, cur2 = cur2, cur2.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cur1: cur.<span class="built_in">next</span> = cur1</span><br><span class="line">    <span class="keyword">if</span> cur2: cur.<span class="built_in">next</span> = cur2</span><br><span class="line">    <span class="keyword">return</span> top.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 20. 有效的括号</title>
    <url>/leetcode/20.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="栈-hash表"><a href="#栈-hash表" class="headerlink" title="栈 + hash表"></a>栈 + hash表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    pip = &#123;<span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">           <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    queue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sign <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> sign <span class="keyword">in</span> pip.keys():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = queue.pop()</span><br><span class="line">                <span class="keyword">if</span> pip[sign] != cur:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue.append(sign)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> queue:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash表</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Transfer Learning of Graph Neural Networks with Ego-graph Information Maximization</title>
    <url>/paper/egi.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>论文地址: <a href="https://arxiv.org/pdf/2009.05204.pdf">2009.05204.pdf</a></p>
<p>代码地址: <a href="https://github.com/GentleZhu/EGI">EGI</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ol>
<li><p>GNN效果良好, 但针对大规模图的训练消耗良多.</p>
</li>
<li><p>在近年进行GNN预训练的研究中, 一是没有提供模型设计的理论支撑, 二是没有清楚地提出模型可转移性的要求和保证.</p>
</li>
<li><p>本文观点: 首先, 对<strong>基本图信息</strong>提出一个新的观点, 主张捕获<strong>基本图信息</strong>作为迁移GNN训练的目标. 这启发了<strong>EGI</strong>的设计, 使用<strong>EGI</strong>实现此目标.<br>其次, 当节点特征与结构相关时, 对目标图和源图局部拉普拉斯的不同进行EGI可转移性分析.</p>
</li>
</ol>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>此次工作为迁移学习GNN构建了一个有理论支撑的框架, 并具现化为一个可实际应用的迁移学习GNN模型.</p>
<p>下图为模型的概览, 其基于一个新的视角: 把图视作节点特征和k阶ego-图结构的联合分布采样.<br>这样的观点使得我们可以通过定义图的信息和相似度来分析图的可迁移性.</p>
<p><span id="GNNframework"><img src="/images/egi_img/framework.png" alt="(图1: 图迁移学习框架图)"></span></p>
<p>我们所设计的模型称作<strong>EGI</strong>.其利用基于ego-图信息最大化的训练目标来有效捕获图信息.</p>
<p>然后我们进一步具体说明了对可迁移节点特征的要求，并分析了依赖于源图和目标图的本地图拉普拉斯算子的 EGI 的可迁移性.</p>
<h1 id="迁移GNN"><a href="#迁移GNN" class="headerlink" title="迁移GNN"></a>迁移GNN</h1><p>在图迁移学习设置中, 预训练过程是无法得知下游任务的.我们认为应该优化和量化GNN的一般效用(general utility).<br>而他捕获基础图信息的能力与图的拓扑结构和节点特征有关.</p>
<p>基于上述观点, 我们设计了ego-图信息最大化模型( ego-graph information maximization model, EGI).<br>然后通过其对目标图和源图建模能力的差距来衡量GNN模型的一般迁移性.</p>
<h2 id="EGI"><a href="#EGI" class="headerlink" title="EGI"></a>EGI</h2><p>此项工作关注于在原图上进行无监督预训练过后的GNN, 在直接迁移设置下, 不经过微调, 直接应用于目标图上.</p>
<table>
<thead>
<tr>
<th align="center">含  义</th>
<th align="center">公  式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">源图</td>
<td align="center">$ G_{a} $</td>
</tr>
<tr>
<td align="center">目标图</td>
<td align="center">$ G_{b} $</td>
</tr>
<tr>
<td align="center">节点特征</td>
<td align="center">$ X $</td>
</tr>
<tr>
<td align="center">节点集</td>
<td align="center">$ V $</td>
</tr>
<tr>
<td align="center">边集</td>
<td align="center">$ E $</td>
</tr>
<tr>
<td align="center">图</td>
<td align="center">$ G &#x3D; \lbrace V, E \rbrace $</td>
</tr>
</tbody></table>
<p>直觉上来说, 只有在源图$ G_{a} $和目标图$ G_{b} $的特征和结构在某些方面相似时, 迁移学习才会成功.<br>因此, 在图$ G_{a} $上进行学习的GNN图滤波( graph filters)能够兼容$ G_{b} $的特征和结构.</p>
<p>我们提出了一个新的观点: 图可以视为节点特征和k阶ego-图结构的联合分布采样.<br>由于这样操作本质是对k阶ego图采样进行编码, 可以帮助我们在迁移学习下对图的结构信息进行具体定义.<br>这样有利于图之间的相似&#x2F;不相似性度量.</p>
<p>我们设计了<strong>EGI</strong>, 此网络通过互信息最大化用以代替k阶图的恢复.</p>
<blockquote>
<p>k阶ego图: 对于节点$ v_{i} $, 只要它具有k层质心扩展, 使得$ v_{i} $到ego图中的人任何节点的最好距离是k ($ \forall v_{i} \in V(g_{i}), |distance(v_{i}, v_{j})| \leq k $), 它的k阶ego图定义为$g_{i} &#x3D; \lbrace V(g_{i}), E(g_{i}) \rbrace $.</p>
</blockquote>
<p>在此次工作中, 我们使用k阶有向图, 其方向由是否到中心节点的输入边还是输出边决定. 当然, 其结果同样适用于无向图.</p>
<blockquote>
<p>结构信息: $ \mathcal{G} $是拓扑空间的子图, $ G $ 视作按照概率$ \mu $从$ \mathcal{G} $采样的独立同分布的k阶ego图$ \lbrace g_{i} \rbrace_{i&#x3D;1}^{n} $. 从而$ G $的结构信息定义为k阶ego图集合$ \lbrace g_{i} \rbrace_{i&#x3D;1}^{n} $和经验分布.</p>
</blockquote>
<p>如<a href="#GNNframework">图1</a>所示, $ G_{0} $, $ G_{1} $, $ G_{2} $通过1阶ego图的集合和经验分布进行区分, 这使得我们能够衡量图之间的结构相似性.</p>
<h3 id="ego图信息最大化"><a href="#ego图信息最大化" class="headerlink" title="ego图信息最大化"></a>ego图信息最大化</h3><p><img src="/images/egi_img/model.png" alt="(图2: EGI框架图)"></p>
<p>给定从经验联合分布$ (g_{i}, x_{i}) \backsim \mathbb{P} $采样的ego图集合$ \lbrace (g_{i}, x_{i}) \rbrace_{i} $.<br>GNN编码器$ \Psi $的训练目标为最大化定义为结构信息的k阶ego图$ g_{i} $和节点嵌入$ z_{i} &#x3D; \Psi(g_{i}, x_{i}) $的互信息$ MI(g_{i}, \Psi(g_{i}, x_{i}))$.<br>为了最大化互信息$ MI $, 引入判别器$ \mathcal{D}(g_{i}, z_{i}): E(g_{i}) \times z_{i} \rightarrow \mathbb{R}^{+} $来计算边$ e $属于ego图$ g_{i} $的概率.<br>EGI模型损失函数使用JS散度:</p>
<p>$$ \mathcal{L}_{EGI} &#x3D; -MI^{(JSD)}( \mathcal{G}, \Psi ) &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^{N} [sp( \mathcal{D}(g_i, z_{i}^{‘})) + sp(-\mathcal{D}(g_i, z_{i}))] \tag{1} \label{eq:one} $$</p>
<p>其中, $ sp(x) &#x3D; \log(1 + e^{x}) $ 是softplus function(一种激活函数), $ (g_{i}, z_{i}^{‘}) $是从边缘分布的乘积中随机抽取的, 即$ z_{i}^{‘} &#x3D; \Psi (g_{i^{‘}}, x_{i^{‘}}), (g_{i^{‘}}, x_{i^{‘}}) \backsim \mathbb{P}, i^{‘} \neq i $.</p>
<p>在$ 式 \eqref{eq:one} $中, 对边是否属于k阶ego图$ E(g_i) $进行计算的判别器$ \mathcal{D} $依赖于节点顺序.<br>以固定的图顺序来描述判别器$ \mathcal{D} $的决策过程.具体来说, $ E(g_i) $的顺序是广度优先遍历(BFS-ordering) $ \pi $.</p>
<p>$ \mathcal{D} &#x3D; f \circ	\Phi $, 通过另一个GNN编码器$ \Phi $和对边序列$ E^{\pi}: \lbrace e_1 , e_2 , \cdots , e_n \rbrace $在有向图层面是否属于k阶ego图进行预测的得分函数$ f $ 输出的准确度得到的召回率进行相乘.</p>
<p>根&#x2F; 中心节点编码器$ \Psi $输入$ (g_i, x_i) $, 在判别器$ \mathcal{D} $中对邻域节点处理的编码器$ \phi $输入$ (\tilde{g_i}, x_i) $：</p>
<p>$$ \Psi(g_i , x_i ) &#x3D; GNN_{\Psi} (A_i, X_i ), \Phi (\tilde{g_i}, x_i ) &#x3D; GNN_{\Phi} (A_{i}^{‘}, X_i) $$</p>
<p>$ A_i, A_{i}^{‘} $是$ g_i, \tilde{g_i} $包括自向边的邻接矩阵.同时$ A_i &#x3D; A_{i}^{‘T}$.自向边的存在使得GNN可以关注到根节点自身的影响.</p>
<p>$ \Psi $ 的输出为$ z_i \in \mathbb{R}^n $ 是根节点的节点嵌入, $ \Phi $ 的输出$ K \in \mathbb{R}^{|g_i| \times n} $ 为ego图邻域节点的表示.</p>
<p>得到$ H $ 后, 就可以计算得分函数$ f $: 对于每个在边序列的节点对$ (p, q) \in E^{\pi} $, $ h_p $是从$ \Phi $得到的源节点表示, $ x_q $是目标节点特征.</p>
<p>$$ f(h_p, x_q, z_i) &#x3D; \sigma (U^T \cdot	\tau (W^T [h_p || x_q || z_i])) \tag{2} \label{eq:two}$$</p>
<p>$ \sigma $ 和 $ \tau $ 是Sigmoid和ReLU激活函数. </p>
<p>然后, 判别器$ \mathcal{D} $用以区分$ g_i $中边的正负对:正对-$ ((p, q), z_i) $,负对-$ ((p, q), z_{i}^{‘}) $:</p>
<p>$$ \mathcal{D} (g_i, z_i)  &#x3D; \sum_{(p,q) \in E^{\pi}} \log f(h_p, x_q, z_i), \mathcal{D} (g_i, z_{i}^{‘})  &#x3D; \sum_{(p,q)}^{E^{\pi}} \log f(h_p, x_q, z_{i}^{‘}) \tag{3} \label{eq:three} $$</p>
<p>在节点序列中, 我们考虑了两种边$ (p, q) $, 第一种: 边连接了对于根节点来说跨阶的节点; 第二种: 边连接了对于根节点来说同阶的节点.</p>
<p>前述提及了节点对的广度优先遍历(BFS-ordering), 而在$ 式 \eqref{eq:three} $中, 对第一种边的序列变化很敏感, 对第二种不敏感.</p>
<p>基于上述事实, 由于k层GNN的输出仅取决于编码器$ \Psi $和$ \Phi $的k阶ego图, 因此可以通过对$ g_i $的批量采样来并行训练EGI.</p>
<h3 id="EGI-的使用场合"><a href="#EGI-的使用场合" class="headerlink" title="EGI 的使用场合"></a>EGI 的使用场合</h3><p>EGI 的使用场合为直接迁移, 即目标领域标签未知, 其可迁移性是通过没有进行微调的模型性能差异来衡量的.</p>
<h2 id="基于局部图的拉普拉斯可迁移性分析"><a href="#基于局部图的拉普拉斯可迁移性分析" class="headerlink" title="基于局部图的拉普拉斯可迁移性分析"></a>基于局部图的拉普拉斯可迁移性分析</h2><p>此次工作主要为基于源图$ G_a $和目标图$ G_b $之间相似性的GNN的可迁移性.</p>
<p>我们认为GNN的输出由三部分构成: 输入的节点特征, 固定的图拉普拉斯, 学习到的图过滤器.<br>GNN的效用由这三者决定.<br>为了实现这种兼容性，我们要求节点特征与结构有关.</p>
<blockquote>
<p>结构相关节点特征: $g_i$表示有序的中间结点为$ v_i $的ego图, 其节点特征为$ \lbrace x_{p,q}^{i} \rbrace_{p&#x3D;0,q&#x3D;1}^{k,|V_p(g_i)|} $, 其中$ V_p(g_i) $是$ g_i $的k阶节点集合. 只有对于任意属于ego图的节点$ v_q \in V_p(g_i) $有$ x_{p,q}^{i} &#x3D; [f(g_i)]_{p,q} \in \mathbb{R}^d $, 其中$ f: \mathcal{G} \rightarrow \mathbb{R}^{d \times |V(g_i)|} $, 这样的节点特征才可称为结构相关.</p>
</blockquote>
<p>结构相关节点特征要求节点特征是图结构的函数.<br>这样的节点对图结构的变化很敏感, 同时在理想的情况下, 节点特征对图结构是内射的(映射不同的图到不同的特征).<br>这样, 当一个迁移GNN学习到的图过滤器兼容$ G $的结构时, 同样能够兼容$ G $的节点特征.</p>
<blockquote>
<p>GNN可迁移性: 源图$ G_a &#x3D; \lbrace (g_, x_i) \rbrace_{i&#x3D;1}^{n} $和目标图$ G_b &#x3D; \lbrace (g_{i’}, x_{i’}) \rbrace_{i’&#x3D;1}^{m} $以及假设与结构相关的节点特征, k层GCN $ \Psi_{\theta} $, 一阶多项式$ \phi $<br>在以上对$ G_a $和$ G_b $的局部谱域合理的假设下, $ \Psi_{\theta} $的经验性能差异通过$ \mathcal{L}_{EGI} $评估, 满足:</p>
</blockquote>
<p>$$ | \mathcal{L}_{EGI} (G_{a}) - \mathcal{L}_{EGI} (G_{b})| \leq \mathcal{O}( \Delta_{ \mathcal{D}} (G_{a}, G_{b}) + C) \tag{4} \label{eq:four} $$</p>
<p>论文原文, <font color="red"> RHS表示公式右侧</font></p>
<p>其中, $ C $只依赖于图编码器和节点特征.</p>
<p>$ \Delta_{ \mathcal{D}}(G_a ,G_b) $衡量源图和目标图结构区别的方式:</p>
<p>$$ \Delta_{\mathcal{D}}(G_a, G_b) &#x3D; \tilde{C} \frac{1}{nm} \sum_{n}^{i&#x3D;1} \sum_{m}^{i^{‘}&#x3D;1} \lambda_{max} (\tilde{L}_{g_i} - \tilde{L}_{g_{i^{‘}}}) \tag{5} \label{eq:five} $$</p>
<p>其中, $ \lambda_{max} (A) : \lambda_{max}(A^T A)^(1&#x2F;2) $, $ \tilde{L}_{g_i} $通过入度表示$\tilde{g}_i$的归一化图拉普拉斯, $ \tilde{C}$ 一直依赖于 $ \lambda_{max}( \tilde{L}_{g_i}) $ 和 $\mathcal{D}$.</p>
<p><strong>GNN可迁移性</strong>的分析自然举例了我们对于结构相似性和GNN可迁移性之间对应关系的理解.<br>这使得我们可以告知EGI怎样把在源图上训练好的GNN仅仅通过衡量源图和目标图之间的局部拉普拉斯差异, 而不需要任何微调, 就可以在目标图上很好地工作.</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>直接迁移的图编码器为GIN,<br>存在微调迁移的图编码器为GCN,<br>自监督GNN为GVAE, DGI,<br>互信息衡量方法为GMI, MVC,<br>对于预训练GNN, 有MaskGNN和ContextGNN,<br>此外, 对比方法还有Structural Pre-train.</p>
<p><img src="/images/egi_img/experiment1.png" alt="(图3: 实验图)"></p>
]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>github + hexo 简单搭建 github.io 网站</title>
    <url>/build_site.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><p>这里先说一下我的系统配置以供参考</p>
<blockquote>
<p>Ubuntu 20.04 5.13.0-51-generic x86_64</p>
</blockquote>
<h1 id="本地前置要求"><a href="#本地前置要求" class="headerlink" title="本地前置要求"></a>本地前置要求</h1><ul>
<li><p>node.js &gt;&#x3D; 10.13</p>
</li>
<li><p>Git</p>
</li>
<li><p>hexo</p>
</li>
</ul>
<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><p>按照 <a href="https://github.com/nodesource/distributions">官方安装方式</a> , Ubuntu 采用安装命令行, 这里安装的版本是18.4.0.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>

<p>进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm --version</span><br></pre></td></tr></table></figure>

<p>出现版本号, 即为安装成功.</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Ubuntu 安装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>创建一个空文件夹作为 hexo 安装路径的同时也会是网站根目录.</p>
<blockquote>
<p>为了后述具体,此时假设新建的目录路径为: <font color=red>&#x2F;example</font></p>
</blockquote>
<h1 id="github前置要求"><a href="#github前置要求" class="headerlink" title="github前置要求"></a>github前置要求</h1><ul>
<li><p>github账号</p>
<blockquote>
<p>为了后述具体,此时假设github账号</p>
<p>用户名为: test</p>
<p>邮箱为: <a href="mailto:&#x74;&#x65;&#x73;&#116;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x74;&#x65;&#x73;&#116;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p>密码为: 123456</p>
</blockquote>
</li>
<li><p>ssh密匙</p>
</li>
</ul>
<h2 id="新建网站远程仓库"><a href="#新建网站远程仓库" class="headerlink" title="新建网站远程仓库"></a>新建网站远程仓库</h2><ol>
<li><p>New Repository, 命名为</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test.github.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 <strong>test.github.io</strong> , 在与 <font color="red">code</font> 同级的 <font color="red">Settings</font>下打开与 <font color="red">General</font> 同级的 <font color="red">Pages</font>. 在<font color="red">Theme Chooser</font> 下选择<font color="red">Choose a theme</font>.</p>
</li>
<li><p>选择好主题后, 把新弹出的界面拉到底部, 选择<strong>commit changes</strong>, 网站就可以访问了.</p>
</li>
<li><p>输入 test.github.io 访问.</p>
</li>
</ol>
<h2 id="设置ssh密匙"><a href="#设置ssh密匙" class="headerlink" title="设置ssh密匙"></a>设置ssh密匙</h2><p>为了hexo能够顺利push到我们的仓库, 需要在本地电脑设置ssh密匙</p>
<ol>
<li><p>检查本机是否有ssh密匙</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure>

<p> 如果存在 <strong>No such file or directory</strong>, 说明你是第一次使用git, 需要创建ssh.</p>
 <br />

<p> 或者</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p> 没有任何输出, 需要创建ssh.</p>
 <br />

<p> 若有ssh密匙, 直接跳转至第 3 步.</p>
</li>
<li><p>创建ssh密匙</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="built_in">test</span>@163.com</span><br></pre></td></tr></table></figure>

<p> 然后<strong>连续3次回车</strong>, 最终会生成一个文件在 <font color=red>~</font> 下.</p>
</li>
<li><p>打开 <font color=red>~</font> , 找到 <font color=red>.ssh\id_rsa.pub</font> 文件.</p>
<blockquote>
<p>注: 如果打开 <font color=red>~</font> ,没有 <font color=red>.ssh</font> 文件夹, 需要 <kbd>Ctrl</kbd> + <kbd>H</kbd> 显示隐藏文件夹.</p>
</blockquote>
<p> 使用记事本一类的程序打开, 复制所有内容.</p>
</li>
<li><p>打开 github , 点击右上角个人头像, 在弹出的窗口中选择 <font color=red>Settings</font>.<br>然后选择与<font color=red>Public profile</font> 同级 <font color=red>Access</font> 下的<br><font color=red>SHH and GPG keys</font>.</p>
</li>
<li><p>选择 <font color=red>New SSH key </font>.</p>
<blockquote>
<p>title: 随便填</p>
<p>Key: 粘贴从 <font color=red>.ssh\id_rsa.pub</font> 文件复制的内容</p>
</blockquote>
<p> <font color=red>Add SSH key </font>.</p>
</li>
<li><p>测试</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com <span class="comment"># 注意邮箱地址不用改</span></span><br></pre></td></tr></table></figure>

<p> 如果提示<font color=blue>Are you sure you want to continue connecting (yes&#x2F;no)?</font>，输入<strong>yes</strong>, 然后会看到:</p>
<blockquote>
<p>Hi test! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p> 看到这个信息说明SSH已配置成功!</p>
</li>
</ol>
<h2 id="Git本地配置："><a href="#Git本地配置：" class="headerlink" title="Git本地配置："></a>Git本地配置：</h2><p>打开命令行, 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;test&quot;</span>            // 你的github用户名，非昵称</span><br><span class="line">git config --global user.email  <span class="string">&quot;test@163.com&quot;</span>  // 填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在 <font color=red>&#x2F;example</font> 目录下, 打开命令行, 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h2 id="加载主题"><a href="#加载主题" class="headerlink" title="加载主题"></a>加载主题</h2><p>在<a href="https://hexo.io/themes/">Hexo官网</a>选择喜欢的主题, 这里以<a href="https://shen-yu.gitee.io/2019/ayer/#%E4%BB%8B%E7%BB%8D">Ayer 主题</a>为例, 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-theme-ayer -S</span><br></pre></td></tr></table></figure>

<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><ol>
<li><p>主题使用</p>
 <br />

<p> 将 <font color=red>&#x2F;example</font> 目录下的 <strong>_config.yml</strong> 里的 theme 值修改成 ayer</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: ayer</span><br></pre></td></tr></table></figure>
</li>
<li><p>必要插件</p>
 <br />
 
<p> 在 <font color=red>&#x2F;example</font> 目录下, 打开命令行, 输入</p>
 <br />

<ul>
<li><a href="https://github.com/theme-next/hexo-generator-searchdb">搜索</a></li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/hexojs/hexo-generator-feed">RSS 订阅</a></li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
 <br />

<p> 打开<font color=red>&#x2F;example</font> 目录下的 <strong>_config.yml</strong>, 输入</p>
 <br />

<ul>
<li><a href="https://github.com/theme-next/hexo-generator-searchdb">搜索</a></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/hexojs/hexo-generator-feed">RSS 订阅</a></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br><span class="line">hub:</span><br><span class="line">content:</span><br><span class="line">content_limit: 140</span><br><span class="line">content_limit_delim: &quot; &quot;</span><br><span class="line">order_by: -date</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选插件</p>
 <br />
 
<p> 在 <font color=red>&#x2F;example</font> 目录下, 打开命令行, 输入</p>
 <br />

<ul>
<li><a href="https://github.com/netcan/hexo-generator-index-pin-top">文章置顶</a></li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">二次元看板娘</a></li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install npm install --save live2d-widget-model-xxx  <span class="comment"># xxx为你选择的模型</span></span><br></pre></td></tr></table></figure>
 <br />

<p> 打开<font color=red>&#x2F;example</font> 目录下的 <strong>_config.yml</strong>, 输入</p>
 <br />

<ul>
<li><a href="https://github.com/netcan/hexo-generator-index-pin-top">文章置顶</a></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 已存在</span><br><span class="line">index_generator:</span><br><span class="line">path: &#x27;&#x27;</span><br><span class="line">per_page: 10</span><br><span class="line">order_by: -date</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">二次元看板娘</a></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">enable: true</span><br><span class="line">scriptFrom: local</span><br><span class="line">pluginRootPath: live2dw/</span><br><span class="line">pluginJsPath: lib/</span><br><span class="line">pluginModelPath: assets/</span><br><span class="line">tagMode: false</span><br><span class="line">debug: false</span><br><span class="line">model:</span><br><span class="line">  use: live2d-widget-model-wanko  # 选择模型</span><br><span class="line">display:</span><br><span class="line">  position: right</span><br><span class="line">  width: 150</span><br><span class="line">  height: 300</span><br><span class="line">mobile:</span><br><span class="line">  show: true</span><br><span class="line">react:</span><br><span class="line">  opacity: 0.7</span><br></pre></td></tr></table></figure>

<p> 更多插件查看 <a href="https://hexo.io/plugins/">hexo 插件市场</a>.</p>
</li>
<li><p>菜单处理</p>
 <br />

<p> Ayer 初始情况下, 菜单的<font color=blue>分类(categories), 标签(tags), 旅行(tags&#x2F;旅行), 友链(friends), 关于我(2019&#x2F;about)</font>, 点击全部显示 <font color=red>error</font>, 需要初始化.</p>
<p> 模板, 对 XX(path) 的初始化:</p>
 <br />

<p> a. 在 <font color=red>&#x2F;example</font> 目录下, 打开命令行, 输入</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page XX</span><br></pre></td></tr></table></figure>

<p> b. 打开 <font color=red>&#x2F;example&#x2F;source&#x2F;XX</font>, 复制 <strong>index.md</strong> 到 <font color=red>&#x2F;example&#x2F;source&#x2F;path</font>, 删除 <font color=red>&#x2F;example&#x2F;source&#x2F;XX</font> 目录.</p>
 <br />

<p> c. 打开 <strong>index.md</strong>, 全部替换输入</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: XX</span><br><span class="line">type: &quot;XX&quot;</span><br><span class="line">layout: &quot;XX&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地测试</p>
 <br />

<p> 在完成上述操作后网站模板搭建完毕, 可以在本地查看网站效果.</p>
 <br />

<p> 在 <font color=red>&#x2F;example</font> 目录下, 打开命令行, 输入</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo 网站生成命令</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># hexo 网站本地部署命令</span></span><br><span class="line">hexo s -p 8008</span><br></pre></td></tr></table></figure>

<p>打开<font color=blue> <a href="http://localhost:8008/">http://localhost:8008/</a> </font> 即可查看部署效果.</p>
</li>
<li><p>部署处理</p>
 <br />

<p> 在push网站到git之前, 要在<font color=red>&#x2F;example</font> 目录下的 <strong>_config.yml</strong>, 输入</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:test/test.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p>在 <font color=red>&#x2F;example</font> 目录下, 打开命令行, 输入下述命令部署到云端.</p>
<br />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo 网站生成命令</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># hexo 网站云端部署命令</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p> 打开<font color=blue> <a href="https://test.github.io/">https://test.github.io/</a> </font> 即可查看部署效果.</p>
</li>
</ol>
<h2 id="新增页面"><a href="#新增页面" class="headerlink" title="新增页面"></a>新增页面</h2><p>   文章页面的新增和菜单的处理不同.</p>
<ol>
<li><p>在 <font color=red>&#x2F;example&#x2F;source&#x2F;_posts</font> 目录下, 新建md文件.</p>
</li>
<li><p>md写入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章名</span><br><span class="line">date: 2022-07-02 21:22:45       # 时间</span><br><span class="line">tags: [网站, hexo, github]      # 标签, 可以填入多个</span><br><span class="line">categories: [网站]              # 只能填入一个</span><br><span class="line">---</span><br><span class="line">正文</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上, 网站搭建完成.</p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Mask RCNN Pytorch版本</title>
    <url>/paper/maskrcnn_pytorch.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>本次实现的Mask RCNN主要分为以下几个部分：</p>
<ul>
<li><p>backbone</p>
</li>
<li><p>RPN</p>
</li>
</ul>
<h1 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h1><p>首先原文提出了四种backbone：</p>
<ul>
<li>resnet50</li>
<li>resnet50 + FPN</li>
<li>resnet101</li>
<li>resnet101 + FPN</li>
</ul>
<p>本次基于resnet101 + FPN实现</p>
<h2 id="resnet101-1"><a href="#resnet101-1" class="headerlink" title="resnet101[1]"></a>resnet101<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.](http://openaccess.thecvf.com/content_cvpr_2016/html/He_Deep_Residual_Learning_CVPR_2016_paper.html)">[1]</span></a></sup></h2><p>就是基础的resnet模型, 可借用torchvision实现</p>
<p><img src="/images/maskrcnn_pytorch/resnet.png" alt="(resnet模型图)"></p>
<h2 id="特征金字塔-FPN-2"><a href="#特征金字塔-FPN-2" class="headerlink" title="特征金字塔(FPN)[2]"></a>特征金字塔(FPN)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Lin T Y, Dollár P, Girshick R, et al. Feature pyramid networks for object detection[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 2117-2125.](https://arxiv.org/abs/1612.03144)">[2]</span></a></sup></h2><p>FPN, 又称特征金字塔, 初始的FPN使用来进行目标检测的, 但由于其性能, 现大多用来做特征提取.</p>
<p><img src="/images/maskrcnn_pytorch/base_fpn.png" alt="(FPN模型图)"></p>
<p>基础的FPN先对高层特征图<strong>上采样</strong>(2倍的最邻近插值), 再对低层特征图<strong>升维</strong>(1 * 1 卷积), 最后对维度, 高度, 宽度一致的两个特征图进行元素对应相加, 得到融合特征图.</p>
<p><img src="/images/maskrcnn_pytorch/rcnn_fpn.jpg" alt="(resnet模型图)&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;[Mask-RCNN 算法及其实现详解](https://blog.csdn.net/remanented/article/details/79564045)
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;"></p>
<p>Mask RCNN内的FPN上采样部分不变, 在<strong>升维</strong>部分, 这里的处理是把所有特征图维度处理至<font color="blue">256</font>.</p>
<p>在得到第一次<strong>P5, P4, P3, P2</strong>后, 对每一个特征图作3 * 3 卷积, 输出仍为<font color="blue">256</font>.</p>
<p>如图示, <strong>P6, P5, P4, P3, P2</strong>会送至<strong>RPN层</strong>.</p>
<h1 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://openaccess.thecvf.com/content_cvpr_2016/html/He_Deep_Residual_Learning_CVPR_2016_paper.html">He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://arxiv.org/abs/1612.03144">Lin T Y, Dollár P, Girshick R, et al. Feature pyramid networks for object detection[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 2117-2125.</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/remanented/article/details/79564045">Mask-RCNN 算法及其实现详解</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>语义分割</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>语义分割</tag>
        <tag>COCO</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 1. 两数之和</title>
    <url>/leetcode/1.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="使用快速排序-原数组index记录-双指针"><a href="#使用快速排序-原数组index记录-双指针" class="headerlink" title="使用快速排序 + 原数组index记录 + 双指针"></a>使用快速排序 + 原数组index记录 + 双指针</h1><ol>
<li>快速排序 + 原数组index记录</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> nums[j] &gt; nums[left] <span class="keyword">and</span> i &lt; j: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nums[i] &lt;= nums[left] <span class="keyword">and</span> i &lt; j: i += <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        idx[i], idx[j] = idx[j], idx[i]</span><br><span class="line">    nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">    idx[i], idx[left] = idx[left], idx[i]</span><br><span class="line"></span><br><span class="line">    quick_sort(left, i - <span class="number">1</span>)</span><br><span class="line">    quick_sort(i + <span class="number">1</span>, right)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>双指针</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">0</span> &lt;= i &lt; j &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">    cur = nums[i] + nums[j]</span><br><span class="line">    <span class="keyword">if</span> cur &gt; target:</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> cur &lt; target:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>


<h1 id="官方解法-hash表"><a href="#官方解法-hash表" class="headerlink" title="官方解法: hash表"></a>官方解法: hash表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">in_ = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> in_:</span><br><span class="line">        <span class="keyword">return</span> [in_[target - nums[i]], i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        in_[nums[i]] = i</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>快排</tag>
        <tag>双指针</tag>
        <tag>hash表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 10. 正则表达式匹配</title>
    <url>/leetcode/10.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动态规划-二维数组"><a href="#动态规划-二维数组" class="headerlink" title="动态规划-二维数组"></a>动态规划-二维数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">s, p</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="comment"># 指针未指向字符串s</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 单个字符匹配任意字符</span></span><br><span class="line">        <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 单个字符一对一匹配</span></span><br><span class="line">        <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]</span><br><span class="line">    m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 零到多字符匹配</span></span><br><span class="line">            <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                dp[i][j] |= dp[i][j - <span class="number">2</span>] <span class="comment"># 匹配零个</span></span><br><span class="line">                <span class="keyword">if</span> match(i, j - <span class="number">1</span>):     <span class="comment"># 要进行匹配</span></span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 一对一字符匹配</span></span><br><span class="line">                <span class="keyword">if</span> match(i, j):</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 11. 盛最多水的容器</title>
    <url>/leetcode/11.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="枚举-time-N-x2F-A"><a href="#枚举-time-N-x2F-A" class="headerlink" title="枚举: time N&#x2F;A"></a>枚举: time N&#x2F;A</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">height</span>):</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(height)):</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, (j - i) * <span class="built_in">min</span>(height[j], height[i]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h1 id="双指针收缩"><a href="#双指针收缩" class="headerlink" title="双指针收缩"></a>双指针收缩</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">height</span>):</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">    res = (j - i) * <span class="built_in">min</span>(height[i], height[j])</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> height[i] &gt;= height[j]: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: i += <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, (j - i) * <span class="built_in">min</span>(height[i], height[j]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 15. 三数之和</title>
    <url>/leetcode/15.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快排-双指针"><a href="#快排-双指针" class="headerlink" title="快排 + 双指针"></a>快排 + 双指针</h1><ol>
<li>快排</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    i, j = left, right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> nums[j] &gt; nums[left] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nums[i] &lt;= nums[left] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line"></span><br><span class="line">    quick_sort(left, i - <span class="number">1</span>)</span><br><span class="line">    quick_sort(i + <span class="number">1</span>, right)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>双指针(三指针)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_len - <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> nums[k] == nums[k - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">    i, j = k + <span class="number">1</span>, num_len - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        cur = nums[k] + nums[i] + nums[j]</span><br><span class="line">        <span class="keyword">if</span> cur &gt; <span class="number">0</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cur &lt; <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>快排</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 17. 电话号码的字母组合</title>
    <url>/leetcode/17.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">digits</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">    hash_ = &#123;<span class="string">&quot;2&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>],</span><br><span class="line">             <span class="string">&quot;3&quot;</span>: [<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>],</span><br><span class="line">             <span class="string">&quot;4&quot;</span>: [<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>],</span><br><span class="line">             <span class="string">&quot;5&quot;</span>: [<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>],</span><br><span class="line">             <span class="string">&quot;6&quot;</span>: [<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>],</span><br><span class="line">             <span class="string">&quot;7&quot;</span>: [<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>],</span><br><span class="line">             <span class="string">&quot;8&quot;</span>: [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>],</span><br><span class="line">             <span class="string">&quot;9&quot;</span>: [<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]&#125;</span><br><span class="line">    </span><br><span class="line">    tmp, res = [<span class="string">&quot;&quot;</span>], []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">        <span class="keyword">if</span> d <span class="keyword">in</span> hash_:</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">for</span> ad <span class="keyword">in</span> hash_[d]:</span><br><span class="line">                    res.append(t + ad)</span><br><span class="line">            <span class="comment"># res += add_</span></span><br><span class="line">            tmp = res</span><br><span class="line">            res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>回溯 + 队列</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">digits</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    hash_ = &#123;<span class="string">&quot;2&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>],</span><br><span class="line">             <span class="string">&quot;3&quot;</span>: [<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>],</span><br><span class="line">             <span class="string">&quot;4&quot;</span>: [<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>],</span><br><span class="line">             <span class="string">&quot;5&quot;</span>: [<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>],</span><br><span class="line">             <span class="string">&quot;6&quot;</span>: [<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>],</span><br><span class="line">             <span class="string">&quot;7&quot;</span>: [<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>],</span><br><span class="line">             <span class="string">&quot;8&quot;</span>: [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>],</span><br><span class="line">             <span class="string">&quot;9&quot;</span>: [<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]&#125;</span><br><span class="line">    </span><br><span class="line">    tmp, res, digit_len = [], [], <span class="built_in">len</span>(digits)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">idx, digit_len</span>):</span><br><span class="line">        <span class="keyword">if</span> idx == digit_len:</span><br><span class="line">            res.append(<span class="string">&quot;&quot;</span>.join(tmp))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            digit = digits[idx]</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> hash_[digit]:</span><br><span class="line">                tmp.append(d)</span><br><span class="line">                back(idx + <span class="number">1</span>, digit_len)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    back(<span class="number">0</span>, digit_len)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 19. 删除链表的倒数第 N 个结点</title>
    <url>/leetcode/19.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="预置"><a href="#预置" class="headerlink" title="预置"></a>预置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br></pre></td></tr></table></figure>

<h1 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">head, n</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line">    node_len, node_cur = <span class="number">0</span>, head</span><br><span class="line">    <span class="keyword">while</span> node_cur:</span><br><span class="line">        node_cur = node_cur.<span class="built_in">next</span></span><br><span class="line">        node_len += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    top = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line"></span><br><span class="line">    left_n, cur = node_len - n, top</span><br><span class="line">    <span class="comment"># print(node_len, left_n)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left_n &gt; <span class="number">0</span>:</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        left_n -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># print(cur.val)</span></span><br><span class="line">    cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 2. 两数相加</title>
    <url>/leetcode/2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简单遍历链表"><a href="#简单遍历链表" class="headerlink" title="简单遍历链表"></a>简单遍历链表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, cur_num, next_ = l1, l2, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">    total = a.val + b.val + next_</span><br><span class="line">    cur_num = total % <span class="number">10</span></span><br><span class="line">    next_ = total // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    a.val = cur_num</span><br><span class="line">    b.val = cur_num</span><br><span class="line"></span><br><span class="line">    a = a.<span class="built_in">next</span></span><br><span class="line">    b = b.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        total = a.val + next_</span><br><span class="line">        cur_num = total % <span class="number">10</span></span><br><span class="line">        next_ = total // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        a.val = cur_num</span><br><span class="line">        a = a.<span class="built_in">next</span></span><br><span class="line">    res = l1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        total = b.val + next_</span><br><span class="line">        cur_num = total % <span class="number">10</span></span><br><span class="line">        next_ = total // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        b.val = cur_num</span><br><span class="line">        b = b.<span class="built_in">next</span></span><br><span class="line">    res = l2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next_ &gt; <span class="number">0</span>:</span><br><span class="line">    cur = res</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = ListNode(next_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 2089. 找出数组排序后的目标下标</title>
    <url>/leetcode/2089.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="排序-查找"><a href="#排序-查找" class="headerlink" title="排序 + 查找"></a>排序 + 查找</h1><ol>
<li>排序: 快速排序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_b2s</span>(<span class="params">nums, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    i, j= left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> nums[j] &gt; nums[left] <span class="keyword">and</span> i &lt; j: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nums[i] &lt;= nums[left] <span class="keyword">and</span> i &lt; j: i += <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    sort_b2s(nums, left, i - <span class="number">1</span>)</span><br><span class="line">    sort_b2s(nums, i + <span class="number">1</span>, right)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查找: 二分查找</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_left</span>(<span class="params">nums, left, right, x</span>):</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + right &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= x:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_right</span>(<span class="params">nums, left, right, x</span>):</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; x:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>快排</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 2090. 半径为k的子数组平均值</title>
    <url>/leetcode/2090.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="使用前缀和-双指针实现"><a href="#使用前缀和-双指针实现" class="headerlink" title="使用前缀和 + 双指针实现"></a>使用前缀和 + 双指针实现</h1><ol>
<li>前缀和</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curs = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    curs.append(curs[-<span class="number">1</span>] + n)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>双指针</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right, res, nums_len = -k - <span class="number">1</span>, k - <span class="number">1</span>, [], <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nums_len):</span><br><span class="line">    left += <span class="number">1</span></span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; nums_len:</span><br><span class="line">        cur = curs[right + <span class="number">1</span>] - curs[left]</span><br><span class="line">        res.append(cur // (<span class="number">2</span> * k + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 3. 无重复字符的最长子串</title>
    <url>/leetcode/3.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="哈希表-双指针"><a href="#哈希表-双指针" class="headerlink" title="哈希表 + 双指针"></a>哈希表 + 双指针</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res, bi, left, right = <span class="number">1</span>, <span class="built_in">set</span>(), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">bi.add(s[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s[i] <span class="keyword">in</span> bi:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[i]:</span><br><span class="line">                bi.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    bi.add(s[i])</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(right - left + <span class="number">1</span>, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>hash表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 4. 寻找两个正序数组的中位数</title>
    <url>/leetcode/4.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">len_1, len_2 = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">len_1a2 = len_1 + len_2</span><br><span class="line">mid = len_1a2 &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">l1, l2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">s, m = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> mid &gt;= <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> l1 &lt; len_1 <span class="keyword">and</span> l2 &lt; len_2:</span><br><span class="line">        <span class="keyword">if</span> nums1[l1] &gt; nums2[l2]:</span><br><span class="line">            cur = nums2[l2]</span><br><span class="line">            l2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = nums1[l1]</span><br><span class="line">            l1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> l1 &lt; len_1:</span><br><span class="line">        cur = nums1[l1]</span><br><span class="line">        l1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = nums2[l2]</span><br><span class="line">        l2 += <span class="number">1</span></span><br><span class="line">    s, m = m, cur</span><br><span class="line">    mid -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">float</span>(s + m) / <span class="number">2</span> <span class="keyword">if</span> <span class="keyword">not</span> len_1a2 % <span class="number">2</span> <span class="keyword">else</span> <span class="built_in">float</span>(m)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 5. 最长回文子串</title>
    <url>/leetcode/5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">expend_substr</span>(<span class="params">left, right</span>):</span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; s_l <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最终回文的始终</span></span><br><span class="line">    start, end, s_l = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_l):</span><br><span class="line">        <span class="comment"># 偶数回文</span></span><br><span class="line">        left, right = expend_substr(i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right - left &gt; end - start:</span><br><span class="line">            start, end = left, right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 奇数回文</span></span><br><span class="line">        left, right = expend_substr(i, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right - left &gt; end - start:</span><br><span class="line">            start, end = left, right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s[start: end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">s</span>):</span><br><span class="line">    s_len = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s_len &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    dp = [[<span class="literal">False</span>] * s_len <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(s_len)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len):</span><br><span class="line">        dp[i][i] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    max_len, start = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 回文长度</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, s_len + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 回文字符起始位置</span></span><br><span class="line">        <span class="keyword">for</span> st <span class="keyword">in</span> <span class="built_in">range</span>(s_len):</span><br><span class="line">            ed = l + st - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ed &gt;= s_len:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> s[st] != s[ed]:</span><br><span class="line">                dp[st][ed] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">                    dp[st][ed] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[st][ed] = dp[st + <span class="number">1</span>][ed - <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> dp[st][ed] <span class="keyword">and</span> l &gt; max_len:</span><br><span class="line">                max_len = l</span><br><span class="line">                start = st</span><br><span class="line">    <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
